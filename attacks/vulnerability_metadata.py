"""
Vulnerability Metadata Registry

Centralized repository of vulnerability metadata for consistent reporting.
Each scanner references this registry to populate findings with complete
information for reports and dashboard display.

Usage:
    from attacks.vulnerability_metadata import VULN_REGISTRY, get_vuln_meta
    
    # Get metadata for SQL injection
    meta = get_vuln_meta("sqli")
    finding.impact = meta.impact
    finding.disclosure_days = meta.disclosure_days
    finding.compliance = meta.compliance
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional
from enum import Enum


class Severity(Enum):
    """Standard severity levels with disclosure timelines."""
    CRITICAL = ("critical", 7)    # 7 days disclosure
    HIGH = ("high", 21)           # 21 days disclosure  
    MEDIUM = ("medium", 45)       # 45 days disclosure
    LOW = ("low", 90)             # 90 days disclosure
    INFO = ("info", None)         # No disclosure needed
    
    @property
    def level(self) -> str:
        return self.value[0]
    
    @property
    def disclosure_days(self) -> Optional[int]:
        return self.value[1]


@dataclass
class VulnMeta:
    """
    Complete vulnerability metadata template.
    
    Embedded in scanner output for consistent reporting across:
    - PDF/HTML reports
    - Dashboard display
    - API responses
    - Compliance audits
    """
    # Basic identification
    name: str                           # Human-readable name (e.g., "SQL Injection")
    attack_type: str                    # Internal type (e.g., "sqli")
    
    # Description (6-10 lines explaining the vulnerability)
    description: str
    
    # Classification
    owasp_category: str                 # e.g., "A03:2021 - Injection"
    cwe_id: str                         # e.g., "CWE-89"
    cwe_name: str                       # e.g., "Improper Neutralization of Special Elements"
    cvss_base: float                    # Base CVSS 3.1 score (0-10)
    
    # Severity and disclosure
    severity: str                       # critical, high, medium, low, info
    disclosure_days: int                # Days until responsible disclosure
    
    # Impact statement (what damage can occur)
    impact: str
    
    # Remediation guidance
    remediation: str
    
    # Compliance mappings
    compliance: List[str] = field(default_factory=list)
    
    # Reference URLs
    references: List[str] = field(default_factory=list)
    
    # Additional categorization
    attack_vector: str = "network"      # network, adjacent, local, physical
    privileges_required: str = "none"   # none, low, high
    user_interaction: str = "none"      # none, required
    
    def get_compliance_statement(self) -> str:
        """Generate formatted compliance statement."""
        if not self.compliance:
            return "No specific compliance requirements identified."
        
        return (
            f"This vulnerability may affect compliance with: {', '.join(self.compliance)}. "
            f"Organizations subject to these standards should prioritize remediation."
        )
    
    def get_disclosure_statement(self) -> str:
        """Generate disclosure timeline statement."""
        if self.disclosure_days is None:
            return "This is an informational finding. No disclosure timeline applies."
        
        return (
            f"Based on the {self.severity} severity rating, this vulnerability should be "
            f"remediated within {self.disclosure_days} days following responsible disclosure practices. "
            f"Failure to address within this timeframe may result in public disclosure."
        )


# =============================================================================
# VULNERABILITY REGISTRY
# =============================================================================

VULN_REGISTRY: Dict[str, VulnMeta] = {
    
    # =========================================================================
    # A03:2021 - INJECTION
    # =========================================================================
    
    "sqli": VulnMeta(
        name="SQL Injection",
        attack_type="sqli",
        description="""SQL Injection (SQLi) is a code injection technique that exploits security 
vulnerabilities in an application's database layer. It occurs when user input is incorrectly 
filtered or not strongly typed and unexpectedly executed. Attackers can inject malicious SQL 
statements into entry fields for execution by the backend database. This vulnerability allows 
attackers to view, modify, or delete data they shouldn't have access to. In severe cases, 
attackers can escalate to operating system command execution via database features like 
xp_cmdshell (SQL Server) or INTO OUTFILE (MySQL). SQLi consistently ranks as one of the 
most critical web application vulnerabilities due to its prevalence and severe impact.""",
        owasp_category="A03:2021 - Injection",
        cwe_id="CWE-89",
        cwe_name="Improper Neutralization of Special Elements used in an SQL Command",
        cvss_base=9.8,
        severity="critical",
        disclosure_days=7,
        impact="""CRITICAL IMPACT:
• Complete database compromise - Full read/write access to all database tables
• Authentication bypass - Login without valid credentials
• Data exfiltration - Theft of sensitive PII, credentials, financial data
• Data manipulation - Modify or delete critical business data
• Privilege escalation - Gain admin access through user table manipulation
• Remote code execution - Via xp_cmdshell, INTO OUTFILE, or UDF injection
• Lateral movement - Access to other systems via database links
• Compliance violations - GDPR, PCI-DSS, HIPAA breach notifications required""",
        remediation="""IMMEDIATE ACTIONS:
1. Use parameterized queries (prepared statements) for ALL database operations
2. Implement stored procedures with proper parameterization
3. Apply input validation using whitelist approach
4. Escape all user-supplied input using database-specific escaping functions
5. Use ORM frameworks with built-in SQL injection protection

LONG-TERM FIXES:
6. Implement least privilege database accounts (no DBA access for web apps)
7. Disable dangerous database features (xp_cmdshell, LOAD_FILE, etc.)
8. Deploy Web Application Firewall (WAF) with SQL injection rules
9. Conduct regular code reviews focusing on database interactions
10. Implement database activity monitoring and alerting""",
        compliance=[
            "PCI-DSS 6.5.1 - Injection flaws",
            "OWASP Top 10 A03:2021",
            "CWE-89",
            "HIPAA §164.312(a)(1) - Access Control",
            "SOC 2 CC6.1 - Logical Access",
            "GDPR Article 32 - Security of Processing",
            "NIST SP 800-53 SI-10 - Information Input Validation",
            "ISO 27001 A.14.2.5 - Secure System Engineering"
        ],
        references=[
            "https://owasp.org/www-community/attacks/SQL_Injection",
            "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html",
            "https://cwe.mitre.org/data/definitions/89.html",
            "https://portswigger.net/web-security/sql-injection"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "xss": VulnMeta(
        name="Cross-Site Scripting (XSS)",
        attack_type="xss",
        description="""Cross-Site Scripting (XSS) is a client-side code injection attack where 
malicious scripts are injected into trusted websites. XSS occurs when an application includes 
untrusted data in a web page without proper validation or escaping. There are three main types:
Reflected XSS (non-persistent), Stored XSS (persistent), and DOM-based XSS. Attackers use XSS 
to execute scripts in victims' browsers to hijack sessions, deface websites, redirect users to 
malicious sites, or steal sensitive information. XSS attacks exploit the trust a user has for a 
particular site, making them highly effective for phishing and credential theft. Modern frameworks 
provide some protection, but improper use of innerHTML or dangerouslySetInnerHTML negates these.""",
        owasp_category="A03:2021 - Injection",
        cwe_id="CWE-79",
        cwe_name="Improper Neutralization of Input During Web Page Generation",
        cvss_base=6.1,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Session hijacking - Steal session cookies to impersonate users
• Credential theft - Capture login credentials via fake forms
• Keylogging - Record all user keystrokes on affected pages
• Phishing attacks - Display convincing fake content/login forms
• Malware distribution - Redirect users to malicious downloads
• Account takeover - Full control of victim user accounts
• Defacement - Modify page content visible to users
• Cryptocurrency mining - Use victim's browser for mining
• Worm propagation - Self-replicating XSS in stored contexts""",
        remediation="""IMMEDIATE ACTIONS:
1. Encode output based on context (HTML, JavaScript, URL, CSS)
2. Use Content-Security-Policy (CSP) headers to restrict script execution
3. Set HttpOnly and Secure flags on session cookies
4. Implement input validation using whitelist approach

LONG-TERM FIXES:
5. Use modern frameworks with automatic XSS protection (React, Angular, Vue)
6. Avoid innerHTML, document.write, eval() with user data
7. Implement Subresource Integrity (SRI) for external scripts
8. Use templating engines that auto-escape by default
9. Deploy Web Application Firewall with XSS detection rules
10. Regular security testing including DOM-based XSS detection""",
        compliance=[
            "PCI-DSS 6.5.7 - Cross-site scripting",
            "OWASP Top 10 A03:2021",
            "CWE-79",
            "HIPAA §164.312(e)(1) - Transmission Security",
            "SOC 2 CC6.1 - Logical Access",
            "GDPR Article 32 - Security of Processing",
            "NIST SP 800-53 SI-10 - Information Input Validation"
        ],
        references=[
            "https://owasp.org/www-community/attacks/xss/",
            "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html",
            "https://cwe.mitre.org/data/definitions/79.html",
            "https://portswigger.net/web-security/cross-site-scripting"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "ssti": VulnMeta(
        name="Server-Side Template Injection (SSTI)",
        attack_type="ssti",
        description="""Server-Side Template Injection occurs when user input is embedded into a 
template engine in an unsafe manner, allowing attackers to inject template directives. Unlike 
client-side template injection, SSTI executes on the server and can lead to Remote Code Execution 
(RCE). Common vulnerable template engines include Jinja2 (Python/Flask), Twig (PHP), Freemarker 
(Java), Velocity (Java), Smarty (PHP), and ERB (Ruby). The attack typically starts with detecting 
the template engine using mathematical expressions like {{7*7}} or ${7*7}. Once identified, 
attackers craft payloads specific to that engine to achieve code execution. SSTI is particularly 
dangerous because it often goes undetected by traditional security tools and WAFs.""",
        owasp_category="A03:2021 - Injection",
        cwe_id="CWE-1336",
        cwe_name="Improper Neutralization of Special Elements Used in a Template Engine",
        cvss_base=9.8,
        severity="critical",
        disclosure_days=7,
        impact="""CRITICAL IMPACT:
• Remote Code Execution (RCE) - Execute arbitrary system commands
• Complete server compromise - Full control of the web server
• Data exfiltration - Access any file the web server can read
• Lateral movement - Pivot to internal network systems
• Service disruption - Crash or manipulate application behavior
• Configuration exposure - Read environment variables, secrets
• Persistent backdoor - Install web shells or reverse shells
• Supply chain attacks - Modify application code or dependencies""",
        remediation="""IMMEDIATE ACTIONS:
1. Never pass user input directly to template render functions
2. Use sandboxed template environments where available
3. Disable dangerous template features and functions
4. Implement strict input validation before template processing

LONG-TERM FIXES:
5. Use logic-less templates (Mustache) when possible
6. Separate template logic from user-controllable data
7. Keep template engines updated to latest versions
8. Implement template security configurations:
   - Jinja2: sandbox mode, disable autoescape bypass
   - Twig: sandbox extension, disable dangerous filters
   - Freemarker: disable new() built-in
9. Conduct code review of all template usage
10. Deploy runtime application self-protection (RASP)""",
        compliance=[
            "PCI-DSS 6.5.1 - Injection flaws",
            "OWASP Top 10 A03:2021",
            "CWE-1336",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SI-10 - Information Input Validation",
            "ISO 27001 A.14.2.5 - Secure System Engineering"
        ],
        references=[
            "https://portswigger.net/research/server-side-template-injection",
            "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/18-Testing_for_Server-side_Template_Injection",
            "https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "cmdi": VulnMeta(
        name="OS Command Injection",
        attack_type="cmdi",
        description="""OS Command Injection (also known as shell injection) is a vulnerability that 
allows attackers to execute arbitrary operating system commands on the server. It occurs when an 
application passes unsafe user input to a system shell. Common vulnerable functions include 
system(), exec(), popen(), shell_exec(), and backtick operators. Attackers typically use command 
separators (;, |, ||, &&, newlines) to chain malicious commands. This vulnerability provides 
direct access to the underlying operating system, making it one of the most severe web vulnerabilities. 
Even partial command injection can be leveraged for data exfiltration through out-of-band techniques 
like DNS or HTTP requests. Blind command injection uses time delays or network callbacks for detection.""",
        owasp_category="A03:2021 - Injection",
        cwe_id="CWE-78",
        cwe_name="Improper Neutralization of Special Elements used in an OS Command",
        cvss_base=9.8,
        severity="critical",
        disclosure_days=7,
        impact="""CRITICAL IMPACT:
• Remote Code Execution - Execute any OS command as web server user
• Complete system compromise - Full control of the server
• Data exfiltration - Access any file readable by web process
• Privilege escalation - Potential root access via local exploits
• Network pivoting - Access internal systems and services
• Malware installation - Deploy ransomware, cryptominers, backdoors
• Service disruption - Delete files, crash services, DoS
• Log tampering - Cover tracks by modifying/deleting logs
• Lateral movement - Attack other systems in the network""",
        remediation="""IMMEDIATE ACTIONS:
1. NEVER use shell commands with user input - use native APIs instead
2. If unavoidable, use strict whitelist of allowed characters/values
3. Use parameterized command execution where available
4. Implement least privilege - run web apps as non-root user

LONG-TERM FIXES:
5. Replace system() calls with language-native libraries:
   - File operations: Use file APIs, not shell commands
   - Network operations: Use socket libraries
   - Image processing: Use imagemagick libraries, not CLI
6. Implement application sandboxing (containers, seccomp)
7. Deploy runtime application protection (RASP)
8. Use chroot/jail environments for the web application
9. Monitor for unusual process spawning patterns
10. Disable unnecessary shell access on web servers""",
        compliance=[
            "PCI-DSS 6.5.1 - Injection flaws",
            "OWASP Top 10 A03:2021",
            "CWE-78",
            "HIPAA §164.312(a)(1) - Access Control",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SI-10 - Information Input Validation"
        ],
        references=[
            "https://owasp.org/www-community/attacks/Command_Injection",
            "https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html",
            "https://cwe.mitre.org/data/definitions/78.html",
            "https://portswigger.net/web-security/os-command-injection"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "xxe": VulnMeta(
        name="XML External Entity (XXE) Injection",
        attack_type="xxe",
        description="""XML External Entity (XXE) injection is a vulnerability that targets 
applications parsing XML input. It exploits the XML parser's ability to load external entities 
defined within the Document Type Definition (DTD). Attackers can abuse this to read local files, 
perform Server-Side Request Forgery (SSRF), execute denial of service attacks, or in some cases 
achieve remote code execution. XXE can occur in any application that accepts XML, including SOAP 
services, SAML authentication, RSS feeds, and document uploads (DOCX, XLSX). Many XML parsers 
have external entity processing enabled by default, making this vulnerability widespread. Blind 
XXE uses out-of-band techniques when direct output isn't visible in the response.""",
        owasp_category="A05:2021 - Security Misconfiguration",
        cwe_id="CWE-611",
        cwe_name="Improper Restriction of XML External Entity Reference",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Local file disclosure - Read any file accessible to web process
• Server-Side Request Forgery (SSRF) - Access internal services
• Internal network scanning - Probe internal infrastructure
• Denial of Service - Billion laughs attack, recursive entities
• Remote Code Execution - Via expect:// or similar protocols
• Cloud metadata access - Steal AWS/GCP credentials via metadata API
• Configuration exposure - Read application configs, credentials
• Blind data exfiltration - Via DNS/HTTP out-of-band channels""",
        remediation="""IMMEDIATE ACTIONS:
1. Disable external entity processing in XML parser:
   - PHP: libxml_disable_entity_loader(true)
   - Java: factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)
   - .NET: XmlReaderSettings.DtdProcessing = DtdProcessing.Prohibit
   - Python: defusedxml library
2. Disable DTD processing entirely if not needed
3. Use less complex data formats (JSON) where possible

LONG-TERM FIXES:
4. Update XML libraries to latest patched versions
5. Implement input validation for XML documents
6. Use XML schema validation (XSD) for expected structure
7. Deploy Web Application Firewall with XXE detection
8. Implement network egress filtering to prevent OOB exfiltration
9. Regular security testing of all XML processing endpoints
10. Audit third-party libraries for XML parsing vulnerabilities""",
        compliance=[
            "PCI-DSS 6.5.1 - Injection flaws",
            "OWASP Top 10 A05:2021",
            "CWE-611",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SI-10 - Information Input Validation"
        ],
        references=[
            "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing",
            "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html",
            "https://cwe.mitre.org/data/definitions/611.html",
            "https://portswigger.net/web-security/xxe"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "lfi": VulnMeta(
        name="Local File Inclusion (LFI)",
        attack_type="lfi",
        description="""Local File Inclusion (LFI) is a vulnerability that allows attackers to 
include files from the local server through the web application. It typically occurs when user 
input is used to construct file paths without proper validation. Attackers use path traversal 
sequences (../) to escape the intended directory and access sensitive files like /etc/passwd, 
configuration files, or application source code. LFI can be escalated to Remote Code Execution 
through log poisoning, PHP filter chains, or wrapper protocols. Common vulnerable patterns include 
dynamic template inclusion, language file loading, and user-uploaded file processing. Null byte 
injection and encoding bypasses are used to circumvent extension restrictions in older systems.""",
        owasp_category="A01:2021 - Broken Access Control",
        cwe_id="CWE-98",
        cwe_name="Improper Control of Filename for Include/Require Statement",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Sensitive file disclosure - Read passwords, configs, source code
• Source code exposure - Access application logic and secrets
• Log file access - View logs potentially containing credentials
• Session hijacking - Read session files to impersonate users
• Remote Code Execution - Via log poisoning, PHP wrappers
• Information gathering - Map server filesystem structure
• Credential theft - Access database configs, API keys
• Privilege escalation - Read shadow files, SSH keys""",
        remediation="""IMMEDIATE ACTIONS:
1. Use whitelist of allowed files/paths - never use user input in paths
2. Validate and sanitize all path inputs - reject ../ sequences
3. Use basename() to extract filename without directory
4. Implement proper access controls on filesystem

LONG-TERM FIXES:
5. Store allowed files in database with ID references
6. Run web application with minimal filesystem permissions
7. Implement chroot/jail for web application
8. Disable dangerous PHP wrappers (expect://, data://)
9. Configure open_basedir restriction (PHP)
10. Use absolute paths instead of relative paths
11. Monitor for path traversal patterns in WAF
12. Regular code review of file inclusion logic""",
        compliance=[
            "PCI-DSS 6.5.8 - Improper access control",
            "OWASP Top 10 A01:2021",
            "CWE-98",
            "HIPAA §164.312(a)(1) - Access Control",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 AC-3 - Access Enforcement"
        ],
        references=[
            "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/11.1-Testing_for_Local_File_Inclusion",
            "https://cwe.mitre.org/data/definitions/98.html",
            "https://book.hacktricks.xyz/pentesting-web/file-inclusion"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "nosql": VulnMeta(
        name="NoSQL Injection",
        attack_type="nosql",
        description="""NoSQL Injection targets applications using NoSQL databases like MongoDB, 
CouchDB, Redis, or Cassandra. Unlike SQL injection, NoSQL injection exploits the query syntax 
specific to each NoSQL database. Common attack vectors include operator injection ($ne, $gt, 
$regex in MongoDB), JavaScript injection via $where operator, and JSON/BSON manipulation. 
Authentication bypass is particularly common when query operators can be injected into login 
forms. NoSQL databases often lack the strong typing and query parameterization of SQL databases, 
making them susceptible to injection. The impact includes authentication bypass, data extraction, 
and in some cases (particularly with $where) arbitrary JavaScript execution on the database server.""",
        owasp_category="A03:2021 - Injection",
        cwe_id="CWE-943",
        cwe_name="Improper Neutralization of Special Elements in Data Query Logic",
        cvss_base=8.1,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Authentication bypass - Login without valid credentials
• Data exfiltration - Extract entire collections/databases
• Data manipulation - Modify or delete documents
• Denial of Service - Resource-intensive regex, $where loops
• Server-side JavaScript execution - Via $where in MongoDB
• Information disclosure - Error messages reveal structure
• Privilege escalation - Modify user role documents
• Blind data extraction - Via regex-based enumeration""",
        remediation="""IMMEDIATE ACTIONS:
1. Use ODM/ORM properly with parameterized queries
2. Never use $where with user input (MongoDB)
3. Validate and cast input types explicitly
4. Sanitize input - reject operators like $, { characters

LONG-TERM FIXES:
5. Disable server-side JavaScript execution if not needed
6. Use schema validation to enforce document structure
7. Implement proper input type checking:
   - Expect string? Validate it's a string
   - Expect ObjectId? Parse and validate format
8. Use allowlist for query operators if needed
9. Implement least privilege database access
10. Monitor for injection patterns in application logs
11. Deploy database firewall to detect anomalous queries
12. Regular security testing of NoSQL endpoints""",
        compliance=[
            "PCI-DSS 6.5.1 - Injection flaws",
            "OWASP Top 10 A03:2021",
            "CWE-943",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SI-10 - Information Input Validation"
        ],
        references=[
            "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection",
            "https://book.hacktricks.xyz/pentesting-web/nosql-injection",
            "https://nullsweep.com/nosql-injection-cheatsheet/"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    # =========================================================================
    # A01:2021 - BROKEN ACCESS CONTROL
    # =========================================================================
    
    "idor": VulnMeta(
        name="Insecure Direct Object Reference (IDOR)",
        attack_type="idor",
        description="""Insecure Direct Object Reference (IDOR) occurs when an application exposes 
internal implementation objects to users without proper access control validation. This allows 
attackers to bypass authorization by manipulating object references (IDs, filenames, keys) to 
access unauthorized data. Common examples include changing user IDs in URLs to access other users' 
profiles, modifying document IDs to download unauthorized files, or manipulating order numbers to 
view other customers' orders. IDOR is particularly dangerous because it's simple to exploit and 
often affects horizontal privilege escalation (accessing peer accounts) and vertical escalation 
(accessing admin resources). Modern applications with REST APIs are especially susceptible when 
they use predictable resource identifiers without authorization checks.""",
        owasp_category="A01:2021 - Broken Access Control",
        cwe_id="CWE-639",
        cwe_name="Authorization Bypass Through User-Controlled Key",
        cvss_base=6.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Unauthorized data access - View other users' private information
• Data exfiltration - Download files belonging to other users
• Account takeover - Access or modify other user accounts
• Privacy violation - Access PII, medical records, financial data
• Business logic bypass - Skip payment, access premium features
• Bulk data harvesting - Enumerate and download all records
• Compliance violations - Unauthorized access to protected data
• Reputational damage - Customer data exposure incidents""",
        remediation="""IMMEDIATE ACTIONS:
1. Implement proper authorization checks on EVERY resource access
2. Validate user ownership/permission before returning data
3. Use indirect references (session-specific mappings) instead of direct IDs
4. Implement access control at the data layer, not just UI

LONG-TERM FIXES:
5. Use unpredictable identifiers (UUIDs instead of sequential IDs)
6. Implement object-level authorization framework
7. Log and monitor access patterns for anomalies
8. Apply consistent authorization across all API endpoints
9. Conduct regular access control testing
10. Implement rate limiting to prevent enumeration attacks
11. Use automated tools to detect IDOR in CI/CD pipeline
12. Train developers on secure authorization patterns""",
        compliance=[
            "PCI-DSS 7.1 - Limit access to system components",
            "OWASP Top 10 A01:2021",
            "CWE-639",
            "HIPAA §164.312(d) - Person or Entity Authentication",
            "SOC 2 CC6.3 - Role-Based Access",
            "GDPR Article 32 - Security of Processing",
            "NIST SP 800-53 AC-3 - Access Enforcement"
        ],
        references=[
            "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References",
            "https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html",
            "https://portswigger.net/web-security/access-control/idor"
        ],
        attack_vector="network",
        privileges_required="low",
        user_interaction="none"
    ),
    
    # =========================================================================
    # A04:2021 - INSECURE DESIGN
    # =========================================================================
    
    "file_upload": VulnMeta(
        name="Unrestricted File Upload",
        attack_type="file_upload",
        description="""Unrestricted File Upload vulnerability allows attackers to upload malicious 
files to a web server. This can lead to Remote Code Execution if the server processes uploaded 
files (e.g., PHP files being executed), Cross-Site Scripting if HTML/SVG files are served, or 
storage attacks if file size/count limits are missing. Common bypass techniques include extension 
manipulation (double extensions, null bytes), MIME type spoofing, magic bytes preservation with 
malicious content (polyglot files), and content-type confusion. Even when uploads are restricted, 
attackers may upload .htaccess files to reconfigure the server. File upload vulnerabilities are 
particularly critical in applications that allow profile pictures, document uploads, or any 
user-submitted content that gets stored and potentially executed on the server.""",
        owasp_category="A04:2021 - Insecure Design",
        cwe_id="CWE-434",
        cwe_name="Unrestricted Upload of File with Dangerous Type",
        cvss_base=9.8,
        severity="critical",
        disclosure_days=7,
        impact="""CRITICAL IMPACT:
• Remote Code Execution - Upload and execute web shells
• Complete server compromise - Full control via uploaded backdoor
• Stored XSS - Malicious HTML/SVG files served to users
• Defacement - Replace website content with attacker's files
• Malware distribution - Host malicious files for download
• Data theft - Web shell provides access to all server files
• Lateral movement - Pivot to internal systems from compromised server
• Persistence - Hidden backdoors survive application updates
• Denial of Service - Exhaust storage or processing resources""",
        remediation="""IMMEDIATE ACTIONS:
1. Validate file type by content (magic bytes), NOT just extension
2. Use whitelist of allowed file types (not blacklist)
3. Rename uploaded files with random names (remove original extension)
4. Store uploads OUTSIDE web root to prevent direct execution
5. Set uploaded files to non-executable permissions

LONG-TERM FIXES:
6. Implement file size and count limits per user
7. Use dedicated storage service (S3, Azure Blob) with proper ACLs
8. Scan uploaded files with antivirus/malware detection
9. Implement Content-Disposition: attachment for downloads
10. Use Content-Type-Options: nosniff header
11. Process/re-encode images to strip embedded code
12. Implement CSP to mitigate uploaded HTML/SVG XSS
13. Block .htaccess, web.config, and other server config files""",
        compliance=[
            "PCI-DSS 6.5.8 - Improper access control",
            "OWASP Top 10 A04:2021",
            "CWE-434",
            "SOC 2 CC6.6 - Threat Detection",
            "NIST SP 800-53 SI-3 - Malicious Code Protection"
        ],
        references=[
            "https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload",
            "https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html",
            "https://cwe.mitre.org/data/definitions/434.html",
            "https://portswigger.net/web-security/file-upload"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    # =========================================================================
    # A07:2021 - AUTHENTICATION FAILURES
    # =========================================================================
    
    "auth_bypass": VulnMeta(
        name="Authentication Bypass",
        attack_type="auth_bypass",
        description="""Authentication Bypass vulnerabilities allow attackers to circumvent the 
login process and gain unauthorized access. This includes SQL injection in login forms, parameter 
manipulation (changing isAdmin=true), broken session management, default credentials, weak 
password reset mechanisms, and JWT vulnerabilities. Authentication is the first line of defense, 
and its bypass provides immediate access to protected functionality. Common issues include 
client-side authentication checks that can be manipulated, predictable session tokens, session 
fixation vulnerabilities, and failure to invalidate sessions on logout or password change. Multi-
factor authentication can mitigate some issues but may itself contain bypass vulnerabilities.""",
        owasp_category="A07:2021 - Identification and Authentication Failures",
        cwe_id="CWE-287",
        cwe_name="Improper Authentication",
        cvss_base=9.8,
        severity="critical",
        disclosure_days=7,
        impact="""CRITICAL IMPACT:
• Unauthorized access - Enter application without valid credentials
• Account takeover - Access any user account including admin
• Privilege escalation - Gain administrative privileges
• Data breach - Access all data available to bypassed account
• Identity theft - Impersonate legitimate users
• Fraud - Perform unauthorized transactions
• Compliance violation - Uncontrolled access to protected data
• System compromise - Admin access leads to full control""",
        remediation="""IMMEDIATE ACTIONS:
1. Implement proper server-side authentication checks
2. Use parameterized queries for credential verification
3. Never trust client-side authentication state
4. Invalidate sessions on logout and password change

LONG-TERM FIXES:
5. Implement multi-factor authentication (MFA)
6. Use proven authentication frameworks (OAuth 2.0, OpenID Connect)
7. Implement account lockout after failed attempts
8. Use secure session management:
   - Cryptographically random session IDs
   - Proper session expiration
   - Secure and HttpOnly cookies
9. Regularly audit authentication logic
10. Implement logging and monitoring of auth events
11. Use constant-time comparison for credentials
12. Remove default/hardcoded credentials""",
        compliance=[
            "PCI-DSS 8.2 - Authentication management",
            "OWASP Top 10 A07:2021",
            "CWE-287",
            "HIPAA §164.312(d) - Person or Entity Authentication",
            "SOC 2 CC6.1 - Logical Access",
            "GDPR Article 32 - Security of Processing",
            "NIST SP 800-53 IA-2 - Identification and Authentication"
        ],
        references=[
            "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/04-Authentication_Testing/",
            "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html",
            "https://cwe.mitre.org/data/definitions/287.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    # =========================================================================
    # A10:2021 - SERVER-SIDE REQUEST FORGERY
    # =========================================================================
    
    "ssrf": VulnMeta(
        name="Server-Side Request Forgery (SSRF)",
        attack_type="ssrf",
        description="""Server-Side Request Forgery (SSRF) occurs when an attacker can make the 
server perform requests to unintended locations. This exploits the server's network position to 
access internal services, cloud metadata endpoints, or external systems. Common attack vectors 
include URL parameters for PDF generators, image processors, webhooks, and URL preview features. 
SSRF can bypass firewalls since requests originate from the trusted server. In cloud environments, 
SSRF is particularly dangerous as it can access metadata services (169.254.169.254) to steal 
credentials and API keys. Blind SSRF variants use timing or DNS/HTTP out-of-band callbacks for 
detection. SSRF entered the OWASP Top 10 in 2021 due to increased cloud adoption and severity.""",
        owasp_category="A10:2021 - Server-Side Request Forgery",
        cwe_id="CWE-918",
        cwe_name="Server-Side Request Forgery (SSRF)",
        cvss_base=8.6,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Internal network scanning - Discover internal services and hosts
• Access to internal services - Reach protected internal APIs
• Cloud credential theft - Access metadata endpoints (AWS, GCP, Azure)
• Firewall bypass - Make requests from trusted server IP
• Port scanning - Enumerate open ports on internal hosts
• Data exfiltration - Read internal files via file:// protocol
• Remote Code Execution - Via vulnerable internal services
• Denial of Service - Overwhelm internal services with requests
• AWS/cloud account takeover - Steal IAM credentials""",
        remediation="""IMMEDIATE ACTIONS:
1. Validate and sanitize all user-supplied URLs
2. Use allowlist of permitted domains/IPs
3. Block requests to internal/private IP ranges
4. Block cloud metadata endpoints (169.254.169.254, etc.)

LONG-TERM FIXES:
5. Use DNS resolution validation (prevent DNS rebinding)
6. Implement network segmentation for the web server
7. Disable unnecessary URL schemes (file://, gopher://, etc.)
8. Use IMDSv2 (AWS) or equivalent for cloud metadata protection
9. Implement egress filtering at network level
10. Monitor outbound requests for anomalies
11. Use separate network zone for URL fetching functions
12. Deploy SSRF-aware WAF rules""",
        compliance=[
            "PCI-DSS 6.5.9 - Cross-site request forgery",
            "OWASP Top 10 A10:2021",
            "CWE-918",
            "SOC 2 CC6.6 - Threat Detection",
            "NIST SP 800-53 SC-7 - Boundary Protection"
        ],
        references=[
            "https://owasp.org/www-community/attacks/Server_Side_Request_Forgery",
            "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html",
            "https://portswigger.net/web-security/ssrf",
            "https://cwe.mitre.org/data/definitions/918.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    # =========================================================================
    # A02:2021 - CRYPTOGRAPHIC FAILURES
    # =========================================================================
    
    "sensitive_data_exposure": VulnMeta(
        name="Sensitive Data Exposure",
        attack_type="sensitive_data_exposure",
        description="""Sensitive Data Exposure occurs when applications fail to adequately protect 
sensitive information such as credentials, credit cards, personal data, and health records. This 
includes data in transit (missing HTTPS, weak TLS), data at rest (unencrypted databases, plaintext 
passwords), and data in use (logging sensitive data, exposing in error messages). Common issues 
include weak cryptographic algorithms (MD5, SHA1 for passwords), hardcoded encryption keys, 
missing encryption for backups, and improper key management. With increasing privacy regulations 
(GDPR, CCPA, HIPAA), data exposure can result in significant fines and legal liability. This 
vulnerability category was renamed from A3:2017 to reflect broader cryptographic failures.""",
        owasp_category="A02:2021 - Cryptographic Failures",
        cwe_id="CWE-311",
        cwe_name="Missing Encryption of Sensitive Data",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Credential theft - Exposed passwords enable account takeover
• Identity theft - PII exposure enables fraud
• Financial loss - Exposed payment data enables fraud
• Regulatory fines - GDPR: up to 4% global revenue
• Legal liability - Class action lawsuits from affected users
• Reputational damage - Loss of customer trust
• Compliance failure - PCI-DSS, HIPAA, SOC 2 violations
• Competitive harm - Exposed business secrets""",
        remediation="""IMMEDIATE ACTIONS:
1. Encrypt all sensitive data in transit (TLS 1.2+)
2. Encrypt all sensitive data at rest (AES-256)
3. Hash passwords with Argon2id, bcrypt, or scrypt (NOT MD5/SHA1)
4. Remove sensitive data from logs and error messages

LONG-TERM FIXES:
5. Classify data to identify what needs protection
6. Implement proper key management (HSM, vault services)
7. Disable caching for sensitive data responses
8. Use secure headers (HSTS, X-Content-Type-Options)
9. Implement data retention policies - delete unnecessary data
10. Encrypt database backups and verify encryption
11. Rotate encryption keys periodically
12. Conduct regular data discovery scans
13. Implement data loss prevention (DLP) solutions""",
        compliance=[
            "PCI-DSS 3.4 - Render PAN unreadable",
            "PCI-DSS 4.1 - Encrypt transmission",
            "OWASP Top 10 A02:2021",
            "CWE-311",
            "HIPAA §164.312(a)(2)(iv) - Encryption",
            "GDPR Article 32 - Security of Processing",
            "SOC 2 CC6.7 - Data Protection",
            "NIST SP 800-53 SC-28 - Protection of Information at Rest"
        ],
        references=[
            "https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure",
            "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html",
            "https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    # =========================================================================
    # ADDITIONAL COMMON VULNERABILITIES
    # =========================================================================
    
    "csrf": VulnMeta(
        name="Cross-Site Request Forgery (CSRF)",
        attack_type="csrf",
        description="""Cross-Site Request Forgery (CSRF) forces authenticated users to perform 
unwanted actions on a web application. It exploits the trust a site has in the user's browser. 
When a user is authenticated, their browser automatically includes session cookies with every 
request to that site. Attackers craft malicious pages that trigger requests to the target site, 
using the victim's authenticated session. This can result in state-changing operations like 
password changes, money transfers, or data modifications. CSRF attacks target functionality, 
not data theft, as attackers cannot see the response. Modern frameworks include CSRF protection, 
but it's often misconfigured or bypassed through XSS vulnerabilities or API endpoints.""",
        owasp_category="A01:2021 - Broken Access Control",
        cwe_id="CWE-352",
        cwe_name="Cross-Site Request Forgery (CSRF)",
        cvss_base=6.5,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• Unauthorized actions - Perform actions as victim user
• Password/email change - Account takeover via profile update
• Fund transfers - Financial transactions on victim's behalf
• Settings modification - Change security settings
• Data manipulation - Create, update, delete victim's data
• Privilege changes - If admin is victim, impact is critical
• Social engineering amplification - Automated attacks via link clicks""",
        remediation="""IMMEDIATE ACTIONS:
1. Implement anti-CSRF tokens for all state-changing operations
2. Verify token on server-side for every POST/PUT/DELETE request
3. Use SameSite cookie attribute (Strict or Lax)
4. Require re-authentication for sensitive operations

LONG-TERM FIXES:
5. Use framework-provided CSRF protection correctly
6. Implement proper CORS policies
7. Check Referer/Origin headers as defense in depth
8. Use custom request headers for API endpoints
9. Implement token-per-request for high-value operations
10. Never use GET requests for state-changing operations""",
        compliance=[
            "PCI-DSS 6.5.9 - Cross-site request forgery",
            "OWASP Top 10 A01:2021",
            "CWE-352",
            "SOC 2 CC6.1 - Logical Access"
        ],
        references=[
            "https://owasp.org/www-community/attacks/csrf",
            "https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html",
            "https://cwe.mitre.org/data/definitions/352.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "open_redirect": VulnMeta(
        name="Open Redirect",
        attack_type="open_redirect",
        description="""Open Redirect vulnerabilities occur when an application accepts user-
controlled input for URL redirection without proper validation. Attackers can craft malicious 
URLs that appear legitimate but redirect victims to phishing sites or malware. Common vulnerable 
patterns include login redirects (redirect_uri, return_url, next), logout handling, and OAuth 
flows. While considered lower severity than injection flaws, open redirects are valuable for 
phishing attacks since the initial URL domain appears legitimate. They can also be chained with 
other vulnerabilities: SSRF through URL parameters, XSS in redirect destinations, or OAuth token 
theft. SPAs and modern frameworks often handle routing client-side, potentially missing server-side 
validation of redirect targets.""",
        owasp_category="A01:2021 - Broken Access Control",
        cwe_id="CWE-601",
        cwe_name="URL Redirection to Untrusted Site",
        cvss_base=4.3,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• Phishing attacks - Redirect to convincing fake login pages
• Malware distribution - Redirect to malicious downloads
• OAuth token theft - Steal tokens via callback URL manipulation
• Brand damage - Legitimate domain used for malicious purposes
• SSRF amplification - When combined with URL fetching features
• Social engineering - Appears legitimate, bypasses user caution
• Credential theft - Victim enters credentials on attacker site""",
        remediation="""IMMEDIATE ACTIONS:
1. Avoid user input in redirects when possible
2. Use whitelist of allowed redirect destinations
3. For relative redirects, validate path doesn't contain //
4. Strip or encode special characters in redirect URLs

LONG-TERM FIXES:
5. Use indirect references (map IDs to URLs server-side)
6. Implement a redirect confirmation page for external URLs
7. Log and monitor redirect patterns for abuse
8. Add security headers (Content-Security-Policy frame-ancestors)
9. Educate users about verifying final destination URLs
10. Validate OAuth redirect_uri against registered patterns""",
        compliance=[
            "OWASP Top 10 A01:2021",
            "CWE-601",
            "SOC 2 CC6.1 - Logical Access"
        ],
        references=[
            "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/04-Testing_for_Client-side_URL_Redirect",
            "https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html",
            "https://cwe.mitre.org/data/definitions/601.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "html_injection": VulnMeta(
        name="HTML Injection",
        attack_type="html_injection",
        description="""HTML Injection occurs when an attacker can inject HTML code into web pages 
viewed by other users. While related to XSS, HTML injection specifically targets HTML elements 
without necessarily including JavaScript. This allows attackers to modify page appearance, 
create fake forms for credential harvesting, inject malicious links, or manipulate page layout 
for clickjacking. HTML injection is common in user-generated content areas, error messages, 
and profile fields. Even without script execution (due to CSP), HTML injection enables effective 
phishing by creating convincing login forms that submit to attacker-controlled servers. It's also 
used to inject hidden iframes, deceptive content, or CSS-based attacks that can steal data.""",
        owasp_category="A03:2021 - Injection",
        cwe_id="CWE-79",
        cwe_name="Improper Neutralization of Input During Web Page Generation",
        cvss_base=5.4,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• Phishing - Inject fake login forms to steal credentials
• Content spoofing - Display misleading information
• Clickjacking setup - Inject invisible frames
• Defacement - Modify visible page content
• SEO poisoning - Inject hidden links for ranking manipulation
• Social engineering - Display fake security warnings
• CSS injection - Steal data via CSS attribute selectors
• Reputation damage - Brand association with injected content""",
        remediation="""IMMEDIATE ACTIONS:
1. HTML encode all user input before output
2. Use context-aware encoding (HTML, attribute, URL)
3. Implement Content-Security-Policy headers
4. Use allowlist for permitted HTML tags if needed

LONG-TERM FIXES:
5. Use templating engines with automatic encoding
6. Implement HTML sanitization library (DOMPurify, Bleach)
7. Never use innerHTML with untrusted data
8. Apply input validation for expected formats
9. Use CSP frame-ancestors to prevent framing
10. Regular testing for injection vulnerabilities""",
        compliance=[
            "OWASP Top 10 A03:2021",
            "CWE-79",
            "SOC 2 CC6.1 - Logical Access"
        ],
        references=[
            "https://owasp.org/www-community/attacks/Content_Spoofing",
            "https://cwe.mitre.org/data/definitions/79.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "jwt_vulnerabilities": VulnMeta(
        name="JWT Security Vulnerabilities",
        attack_type="jwt_vulnerabilities",
        description="""JWT (JSON Web Token) vulnerabilities arise from improper implementation 
of token-based authentication. Common issues include: algorithm confusion (changing RS256 to HS256 
and signing with public key), none algorithm bypass (setting alg=none to skip verification), weak 
secrets (brute-forceable HMAC keys), missing expiration validation, improper claim validation, 
and JWK injection (kid parameter manipulation). JWTs are stateless by design, making revocation 
difficult without additional infrastructure. Many implementations also store sensitive data in 
the payload without encryption, exposing it to anyone with the token. Token theft through XSS 
or other means provides persistent access until the token expires.""",
        owasp_category="A07:2021 - Identification and Authentication Failures",
        cwe_id="CWE-347",
        cwe_name="Improper Verification of Cryptographic Signature",
        cvss_base=8.1,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Authentication bypass - Forge valid tokens without credentials
• Privilege escalation - Modify role/permission claims
• Account takeover - Create tokens for any user
• Persistent access - Long-lived tokens after password change
• Session hijacking - Stolen tokens provide access
• Information disclosure - Sensitive data in unencrypted payload
• Lateral movement - Forge tokens for other services using same secret""",
        remediation="""IMMEDIATE ACTIONS:
1. Use strong secrets (256+ bits for HMAC)
2. Always validate the alg header server-side
3. Reject 'none' algorithm in production
4. Set and enforce reasonable expiration times

LONG-TERM FIXES:
5. Use asymmetric algorithms (RS256) when possible
6. Implement token refresh mechanism with short-lived access tokens
7. Store minimal data in tokens (user ID only, not roles)
8. Implement token revocation mechanism (blacklist, token versioning)
9. Use JWE for encrypted tokens if payload is sensitive
10. Validate all claims (iss, aud, exp, nbf, iat)
11. Secure token storage client-side (avoid localStorage for sensitive tokens)
12. Implement proper key rotation procedures""",
        compliance=[
            "PCI-DSS 8.2 - Authentication management",
            "OWASP Top 10 A07:2021",
            "CWE-347",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 IA-5 - Authenticator Management"
        ],
        references=[
            "https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/",
            "https://portswigger.net/web-security/jwt",
            "https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "cors_misconfiguration": VulnMeta(
        name="CORS Misconfiguration",
        attack_type="cors_misconfiguration",
        description="""Cross-Origin Resource Sharing (CORS) misconfiguration occurs when web 
applications implement overly permissive CORS policies that allow unauthorized cross-origin 
requests. Common misconfigurations include reflecting the Origin header without validation, 
using wildcard (*) with credentials, trusting null origins, or whitelisting entire domains 
instead of specific subdomains. Attackers exploit these misconfigurations to make authenticated 
requests from malicious websites, stealing sensitive data or performing actions on behalf of 
victims. The vulnerability is particularly severe when combined with credentials (cookies, 
tokens) as it bypasses Same-Origin Policy protections. Modern single-page applications heavily 
rely on CORS, making proper configuration critical for security.""",
        owasp_category="A01:2021 - Broken Access Control",
        cwe_id="CWE-942",
        cwe_name="Permissive Cross-domain Policy with Untrusted Domains",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Data theft - Steal sensitive user data via cross-origin requests
• Session hijacking - Access authenticated endpoints from malicious sites
• Account takeover - Perform actions as authenticated user
• Credential exposure - Extract tokens and session data
• CSRF bypass - Execute state-changing requests bypassing CSRF protections
• API abuse - Access private APIs from unauthorized origins
• Information disclosure - Read responses containing sensitive data
• Privacy violation - Access user PII from different origin""",
        remediation="""IMMEDIATE ACTIONS:
1. Never reflect the Origin header without strict validation
2. Maintain explicit whitelist of trusted origins
3. Avoid using wildcard (*) with Access-Control-Allow-Credentials
4. Reject null origin in production environments

LONG-TERM FIXES:
5. Implement strict origin validation against whitelist
6. Use exact origin matching, not substring or regex
7. Set Access-Control-Allow-Credentials only when necessary
8. Limit exposed headers and methods to minimum required
9. Implement preflight caching with appropriate max-age
10. Regular security audits of CORS configuration
11. Use Content-Security-Policy as defense in depth
12. Monitor for unusual cross-origin request patterns""",
        compliance=[
            "OWASP Top 10 A01:2021",
            "CWE-942",
            "SOC 2 CC6.1 - Logical Access",
            "GDPR Article 32 - Security of Processing",
            "NIST SP 800-53 AC-4 - Information Flow Enforcement"
        ],
        references=[
            "https://portswigger.net/web-security/cors",
            "https://owasp.org/www-community/attacks/CORS_OriginHeaderScrutiny",
            "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS",
            "https://cwe.mitre.org/data/definitions/942.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "clickjacking": VulnMeta(
        name="Clickjacking (UI Redressing)",
        attack_type="clickjacking",
        description="""Clickjacking, also known as UI redressing, is an attack where a malicious 
website tricks users into clicking on something different from what they perceive. The attacker 
loads a legitimate website in a transparent iframe and overlays deceptive UI elements to capture 
user clicks. Victims believe they're interacting with visible elements but are actually clicking 
on hidden elements from the targeted site. This can lead to unintended actions like changing 
account settings, making purchases, liking content, or granting permissions. Modern variations 
include likejacking (social media), cursorjacking (cursor position manipulation), and filejacking 
(file upload manipulation). The attack bypasses CSRF protections since it uses legitimate user 
interactions within an authenticated session.""",
        owasp_category="A01:2021 - Broken Access Control",
        cwe_id="CWE-1021",
        cwe_name="Improper Restriction of Rendered UI Layers or Frames",
        cvss_base=6.1,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• Unauthorized actions - Perform actions without user awareness
• Account modification - Change settings, email, password
• Financial transactions - Initiate payments or transfers
• Social engineering - Force likes, shares, follows
• Permission grants - Approve OAuth, camera, microphone access
• Data exposure - Enable data sharing settings
• Malware installation - Trick users into downloading files
• Reputation damage - Post content on user's behalf""",
        remediation="""IMMEDIATE ACTIONS:
1. Implement X-Frame-Options header (DENY or SAMEORIGIN)
2. Use Content-Security-Policy frame-ancestors directive
3. Add frame-busting JavaScript as fallback protection
4. Set SameSite cookie attribute to Lax or Strict

LONG-TERM FIXES:
5. Use CSP frame-ancestors 'self' for same-origin only
6. Implement confirmation dialogs for sensitive actions
7. Use CAPTCHAs for high-risk operations
8. Deploy click confirmation for financial transactions
9. Implement re-authentication for critical changes
10. Monitor for unusual referrer patterns
11. Consider disabling third-party embedding entirely
12. Regular testing with clickjacking detection tools""",
        compliance=[
            "OWASP Top 10 A01:2021",
            "CWE-1021",
            "PCI-DSS 6.5.9 - Cross-site request forgery",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SC-18 - Mobile Code"
        ],
        references=[
            "https://owasp.org/www-community/attacks/Clickjacking",
            "https://portswigger.net/web-security/clickjacking",
            "https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html",
            "https://cwe.mitre.org/data/definitions/1021.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "http_request_smuggling": VulnMeta(
        name="HTTP Request Smuggling",
        attack_type="http_request_smuggling",
        description="""HTTP Request Smuggling exploits discrepancies in how front-end and back-end 
servers parse HTTP requests, particularly around Content-Length and Transfer-Encoding headers. 
When servers disagree on request boundaries, attackers can "smuggle" hidden requests that bypass 
security controls. Common variants include CL.TE (front-end uses Content-Length, back-end uses 
Transfer-Encoding), TE.CL (opposite), and TE.TE (both use TE but parse differently). Smuggled 
requests can poison web caches, bypass access controls, hijack other users' requests, or achieve 
request routing manipulation. The attack is particularly dangerous in environments with reverse 
proxies, load balancers, or CDNs. HTTP/2 downgrade attacks create new smuggling vectors when 
HTTP/2 is converted to HTTP/1.1 for backend communication.""",
        owasp_category="A05:2021 - Security Misconfiguration",
        cwe_id="CWE-444",
        cwe_name="Inconsistent Interpretation of HTTP Requests",
        cvss_base=9.1,
        severity="critical",
        disclosure_days=7,
        impact="""CRITICAL IMPACT:
• Request hijacking - Capture other users' requests and responses
• Cache poisoning - Store malicious content in shared caches
• Security bypass - Circumvent WAF, authentication, access controls
• Session hijacking - Steal cookies from other users
• Credential theft - Intercept login requests
• Response queue poisoning - Serve malicious responses to victims
• Request routing manipulation - Access internal endpoints
• Privilege escalation - Access admin functionality via smuggled requests""",
        remediation="""IMMEDIATE ACTIONS:
1. Ensure all servers use same HTTP parsing behavior
2. Normalize Content-Length and Transfer-Encoding handling
3. Reject ambiguous requests with both CL and TE headers
4. Update all HTTP processors to latest versions

LONG-TERM FIXES:
5. Use HTTP/2 end-to-end where possible
6. Configure front-end to normalize requests before forwarding
7. Disable HTTP/1.1 connection reuse if not strictly needed
8. Implement request validation at each layer
9. Use consistent timeout configurations across servers
10. Deploy WAF rules specifically for smuggling detection
11. Regular testing with smuggling detection tools
12. Monitor for unusual request patterns and parsing errors""",
        compliance=[
            "OWASP Top 10 A05:2021",
            "CWE-444",
            "PCI-DSS 6.5.10 - Broken authentication",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SC-7 - Boundary Protection"
        ],
        references=[
            "https://portswigger.net/web-security/request-smuggling",
            "https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn",
            "https://cwe.mitre.org/data/definitions/444.html",
            "https://www.rfc-editor.org/rfc/rfc7230"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "web_cache_poisoning": VulnMeta(
        name="Web Cache Poisoning",
        attack_type="web_cache_poisoning",
        description="""Web Cache Poisoning exploits caching mechanisms to serve malicious content 
to other users. Attackers manipulate unkeyed inputs (headers, cookies, query parameters not used 
in cache keys) to inject harmful content that gets cached and served to subsequent visitors. 
Common vectors include X-Forwarded-Host, X-Original-URL, X-Rewrite-URL headers, and fat GET 
requests with bodies. The impact is amplified because a single poisoning request can affect 
thousands of users receiving the cached response. Cache poisoning can lead to XSS, open redirects, 
or serving completely different pages. CDNs, reverse proxies, and application-level caches are 
all potential targets. Cache key normalization differences between layers create additional 
attack surface.""",
        owasp_category="A05:2021 - Security Misconfiguration",
        cwe_id="CWE-349",
        cwe_name="Acceptance of Extraneous Untrusted Data With Trusted Data",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Mass XSS - Deliver scripts to all users accessing cached resource
• Defacement - Modify visible content for all visitors
• Phishing - Serve fake login pages from legitimate domain
• Malware distribution - Inject malicious downloads
• Credential theft - Capture credentials via poisoned pages
• SEO poisoning - Manipulate search engine results
• DoS - Cache error pages or empty responses
• Reputation damage - Serve embarrassing or illegal content""",
        remediation="""IMMEDIATE ACTIONS:
1. Include all variable inputs in cache keys
2. Restrict or sanitize unkeyed header inputs
3. Validate X-Forwarded-* headers against trusted sources
4. Disable caching for pages with user-specific content

LONG-TERM FIXES:
5. Use Vary header correctly to differentiate cached versions
6. Implement strict cache key composition rules
7. Sanitize all header values before use in responses
8. Use signed cache keys to prevent manipulation
9. Implement cache purging capabilities for incidents
10. Monitor cache hit/miss patterns for anomalies
11. Regular testing with cache poisoning tools
12. Use CDN-specific protections against cache poisoning""",
        compliance=[
            "OWASP Top 10 A05:2021",
            "CWE-349",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SI-10 - Information Input Validation"
        ],
        references=[
            "https://portswigger.net/research/practical-web-cache-poisoning",
            "https://portswigger.net/web-security/web-cache-poisoning",
            "https://cwe.mitre.org/data/definitions/349.html",
            "https://owasp.org/www-community/attacks/Cache_Poisoning"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "insecure_deserialization": VulnMeta(
        name="Insecure Deserialization",
        attack_type="insecure_deserialization",
        description="""Insecure Deserialization occurs when applications deserialize untrusted 
data without proper validation, allowing attackers to manipulate serialized objects. This can 
lead to remote code execution, replay attacks, injection attacks, or privilege escalation. 
Vulnerable serialization formats include Java serialization, PHP serialize(), Python pickle, 
.NET BinaryFormatter, and Ruby Marshal. Attackers craft malicious serialized objects containing 
"gadget chains" - sequences of existing classes that execute dangerous operations during 
deserialization. Modern attacks use tools like ysoserial (Java), phpggc (PHP), and similar 
generators. The vulnerability is particularly severe because exploitation often requires no 
authentication and results in immediate code execution.""",
        owasp_category="A08:2021 - Software and Data Integrity Failures",
        cwe_id="CWE-502",
        cwe_name="Deserialization of Untrusted Data",
        cvss_base=9.8,
        severity="critical",
        disclosure_days=7,
        impact="""CRITICAL IMPACT:
• Remote Code Execution - Execute arbitrary code on server
• Complete system compromise - Full control of application server
• Data manipulation - Modify object state and business logic
• Authentication bypass - Manipulate user/session objects
• Privilege escalation - Elevate user roles via object manipulation
• DoS - Resource exhaustion through malicious objects
• Lateral movement - Pivot to internal systems
• Data exfiltration - Access sensitive information""",
        remediation="""IMMEDIATE ACTIONS:
1. Never deserialize untrusted data without validation
2. Use safe serialization formats (JSON, XML) instead of native
3. Implement integrity checks (HMAC) on serialized data
4. Run deserialization with minimal privileges

LONG-TERM FIXES:
5. Implement allowlist of permitted classes for deserialization
6. Use language-specific protections:
   - Java: ObjectInputFilter, RASP solutions
   - PHP: Avoid unserialize(), use JSON
   - Python: Avoid pickle for untrusted data
   - .NET: Avoid BinaryFormatter, use DataContractSerializer
7. Implement deserialization monitoring and alerting
8. Isolate deserialization in sandboxed environments
9. Regular dependency updates to patch gadget chains
10. Use serialization libraries with known-safe configurations
11. Conduct code review for all deserialization usage
12. Deploy RASP with deserialization attack detection""",
        compliance=[
            "OWASP Top 10 A08:2021",
            "CWE-502",
            "PCI-DSS 6.5.1 - Injection flaws",
            "HIPAA §164.312(a)(1) - Access Control",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SI-10 - Information Input Validation"
        ],
        references=[
            "https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data",
            "https://portswigger.net/web-security/deserialization",
            "https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html",
            "https://github.com/frohoff/ysoserial"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "ldap_injection": VulnMeta(
        name="LDAP Injection",
        attack_type="ldap_injection",
        description="""LDAP Injection occurs when user input is incorporated into LDAP queries 
without proper sanitization, allowing attackers to modify query logic. LDAP (Lightweight Directory 
Access Protocol) is commonly used for authentication, authorization, and directory services in 
enterprise environments including Active Directory. Attackers inject LDAP filter metacharacters 
(*, (, ), \\, NUL) to bypass authentication, enumerate users, extract sensitive information, or 
modify directory entries. The attack is similar to SQL injection but targets directory services 
instead of databases. Successful exploitation often provides access to user credentials, group 
memberships, and sensitive organizational data stored in the directory.""",
        owasp_category="A03:2021 - Injection",
        cwe_id="CWE-90",
        cwe_name="Improper Neutralization of Special Elements used in an LDAP Query",
        cvss_base=8.6,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Authentication bypass - Login without valid credentials
• Information disclosure - Enumerate all users and groups
• Privilege escalation - Access admin or service accounts
• Data exfiltration - Extract sensitive directory attributes
• Account lockout - Trigger lockouts for legitimate users
• Directory modification - Change user attributes or passwords
• Lateral movement - Discover network resources and services
• Compliance violation - Unauthorized access to directory data""",
        remediation="""IMMEDIATE ACTIONS:
1. Use parameterized LDAP queries/prepared statements
2. Escape LDAP special characters: * ( ) \\ NUL
3. Implement strict input validation with whitelist
4. Use minimal LDAP query permissions

LONG-TERM FIXES:
5. Use framework LDAP libraries with built-in escaping
6. Implement least privilege for LDAP service accounts
7. Enable LDAP query logging and monitoring
8. Use LDAPS (LDAP over SSL) for all connections
9. Implement rate limiting on authentication attempts
10. Regular security audits of LDAP query construction
11. Consider using SAML or OAuth instead of direct LDAP
12. Deploy WAF rules for LDAP injection detection""",
        compliance=[
            "OWASP Top 10 A03:2021",
            "CWE-90",
            "PCI-DSS 6.5.1 - Injection flaws",
            "HIPAA §164.312(d) - Authentication",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 IA-5 - Authenticator Management"
        ],
        references=[
            "https://owasp.org/www-community/attacks/LDAP_Injection",
            "https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html",
            "https://cwe.mitre.org/data/definitions/90.html",
            "https://portswigger.net/kb/issues/00100500_ldap-injection"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "xpath_injection": VulnMeta(
        name="XPath Injection",
        attack_type="xpath_injection",
        description="""XPath Injection occurs when user input is used to construct XPath queries 
without proper sanitization. XPath is a query language for selecting nodes from XML documents, 
commonly used in authentication systems, data retrieval, and configuration parsing. Attackers 
inject XPath syntax to modify query logic, bypass authentication, or extract data from XML 
documents. Unlike SQL injection, XPath has no concept of different access levels - once exploited, 
the entire XML document is accessible. Blind XPath injection uses boolean conditions to extract 
data character by character. The attack is particularly dangerous in SAML-based SSO implementations 
where XPath queries validate assertions.""",
        owasp_category="A03:2021 - Injection",
        cwe_id="CWE-643",
        cwe_name="Improper Neutralization of Data within XPath Expressions",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Authentication bypass - Bypass login through query manipulation
• Data extraction - Access entire XML document contents
• Information disclosure - Extract sensitive configuration data
• Privilege escalation - Access admin user data
• SAML bypass - Compromise SSO authentication
• Business logic bypass - Modify application behavior
• User enumeration - Discover valid usernames
• Credential theft - Extract stored passwords or secrets""",
        remediation="""IMMEDIATE ACTIONS:
1. Use parameterized XPath queries where available
2. Implement strict input validation with whitelist
3. Escape XPath special characters: ' " [ ] / @ = *
4. Avoid constructing XPath from user input when possible

LONG-TERM FIXES:
5. Use XPath libraries with parameterization support
6. Implement query timeout and result size limits
7. Store sensitive data outside XML documents
8. Use alternative query methods (DOM traversal) if safer
9. Implement defense-in-depth with XML schema validation
10. Regular security testing of XPath query construction
11. Monitor for unusual XPath query patterns
12. Consider moving to JSON for data interchange""",
        compliance=[
            "OWASP Top 10 A03:2021",
            "CWE-643",
            "PCI-DSS 6.5.1 - Injection flaws",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SI-10 - Information Input Validation"
        ],
        references=[
            "https://owasp.org/www-community/attacks/XPATH_Injection",
            "https://portswigger.net/kb/issues/00100600_xpath-injection",
            "https://cwe.mitre.org/data/definitions/643.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "crlf_injection": VulnMeta(
        name="CRLF Injection (HTTP Response Splitting)",
        attack_type="crlf_injection",
        description="""CRLF Injection exploits applications that include user input in HTTP 
headers without sanitizing carriage return (\\r) and line feed (\\n) characters. Attackers 
inject CRLF sequences to terminate headers and inject additional headers or even an entirely 
new HTTP response (HTTP Response Splitting). This enables cache poisoning, XSS via injected 
headers, session fixation via Set-Cookie injection, and security header bypass. The attack 
is particularly effective against redirect endpoints that reflect user input in Location 
headers. Modern frameworks often provide CRLF protection, but custom header handling and 
legacy code remain vulnerable. Log injection is a related vulnerability where CRLF is 
injected into log files.""",
        owasp_category="A03:2021 - Injection",
        cwe_id="CWE-93",
        cwe_name="Improper Neutralization of CRLF Sequences in HTTP Headers",
        cvss_base=6.1,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• XSS - Inject scripts via response body injection
• Cache poisoning - Store malicious responses in caches
• Session fixation - Inject Set-Cookie with attacker's session
• Security bypass - Override security headers (CSP, X-Frame-Options)
• Phishing - Redirect users to malicious sites
• Log poisoning - Inject fake log entries to cover tracks
• Header injection - Add arbitrary HTTP headers
• Cookie manipulation - Set or modify cookies""",
        remediation="""IMMEDIATE ACTIONS:
1. Reject or encode CR (\\r, %0d) and LF (\\n, %0a) in header values
2. Use framework-provided header setting functions
3. Validate all input used in HTTP headers
4. Encode user input before including in headers

LONG-TERM FIXES:
5. Use modern frameworks with built-in CRLF protection
6. Implement output encoding for all header contexts
7. Audit all custom header manipulation code
8. Use URL encoding for redirect destinations
9. Implement WAF rules for CRLF detection
10. Regular security testing of header handling
11. Log and alert on CRLF character detection in input
12. Update to HTTP/2 which has different header handling""",
        compliance=[
            "OWASP Top 10 A03:2021",
            "CWE-93",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SI-10 - Information Input Validation"
        ],
        references=[
            "https://owasp.org/www-community/vulnerabilities/CRLF_Injection",
            "https://portswigger.net/kb/issues/00200200_http-response-header-injection",
            "https://cwe.mitre.org/data/definitions/93.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "host_header_injection": VulnMeta(
        name="Host Header Injection",
        attack_type="host_header_injection",
        description="""Host Header Injection exploits web applications that trust the HTTP Host 
header for generating URLs, redirects, or accessing virtual hosts. Attackers manipulate the 
Host header to inject malicious values that the application uses in password reset links, 
callback URLs, or internal routing. This can lead to password reset poisoning (sending reset 
links to attacker-controlled domains), cache poisoning, server-side request forgery, and 
access to internal virtual hosts. Applications often use the Host header to construct absolute 
URLs for emails, redirects, and canonical links. The X-Forwarded-Host header provides an 
additional attack vector when applications trust proxy headers.""",
        owasp_category="A05:2021 - Security Misconfiguration",
        cwe_id="CWE-644",
        cwe_name="Improper Neutralization of HTTP Headers for Scripting Syntax",
        cvss_base=6.1,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• Password reset poisoning - Steal password reset tokens
• Cache poisoning - Store malicious content in caches
• SSRF-like attacks - Access internal virtual hosts
• Phishing - Generate links to attacker-controlled domains
• Open redirect - Redirect users via manipulated URLs
• Web cache deception - Cache sensitive pages
• Virtual host access - Reach unintended vhosts
• Email link manipulation - Poison transactional emails""",
        remediation="""IMMEDIATE ACTIONS:
1. Configure allowed hosts whitelist at server/framework level
2. Avoid using Host header for generating URLs
3. Use hardcoded or configured base URLs for links
4. Validate Host header against expected values

LONG-TERM FIXES:
5. Configure web server to reject unknown Host headers
6. Use SERVER_NAME environment variable instead of Host
7. Implement strict virtual host configuration
8. Ignore X-Forwarded-Host unless from trusted proxies
9. Store base URL in configuration, not derived from requests
10. Regular testing with modified Host headers
11. Implement password reset link expiration and one-time use
12. Monitor for unusual Host header values""",
        compliance=[
            "OWASP Top 10 A05:2021",
            "CWE-644",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SI-10 - Information Input Validation"
        ],
        references=[
            "https://portswigger.net/web-security/host-header",
            "https://portswigger.net/research/practical-web-cache-poisoning",
            "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/17-Testing_for_Host_Header_Injection"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "subdomain_takeover": VulnMeta(
        name="Subdomain Takeover",
        attack_type="subdomain_takeover",
        description="""Subdomain Takeover occurs when a subdomain points to an external service 
that is no longer in use, allowing attackers to claim the service and control the subdomain's 
content. Common scenarios include expired cloud services (S3, Azure, Heroku, GitHub Pages), 
decommissioned CDN endpoints, or removed third-party integrations. Attackers register the 
abandoned service endpoint and serve malicious content on the legitimate subdomain. This 
enables phishing (content appears to come from trusted domain), cookie theft (if parent domain 
cookies are accessible), and reputation damage. Organizations often have hundreds of subdomains 
making monitoring challenging. The vulnerability persists until DNS records are cleaned up.""",
        owasp_category="A05:2021 - Security Misconfiguration",
        cwe_id="CWE-923",
        cwe_name="Improper Restriction of Communication Channel to Intended Endpoints",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Phishing - Serve convincing phishing pages on trusted domain
• Cookie theft - Access cookies scoped to parent domain
• Credential harvesting - Capture login credentials
• Malware distribution - Serve malicious downloads
• Brand impersonation - Damage reputation through malicious content
• Email spoofing - May enable SPF-based email trust
• SEO poisoning - Inject spam links from trusted domain
• Supply chain attacks - Compromise dependencies using domain""",
        remediation="""IMMEDIATE ACTIONS:
1. Audit all DNS records for dangling CNAME entries
2. Remove DNS records pointing to decommissioned services
3. Verify all external service integrations are active
4. Implement subdomain monitoring for changes

LONG-TERM FIXES:
5. Use DNS CAA records to restrict certificate issuance
6. Implement automated DNS hygiene scanning
7. Integrate subdomain review in service decommissioning process
8. Use domain fronting protections where possible
9. Set restrictive cookie scope (avoid wildcard domains)
10. Maintain inventory of all subdomains and their purposes
11. Regular penetration testing including subdomain enumeration
12. Implement alerts for external service account changes""",
        compliance=[
            "OWASP Top 10 A05:2021",
            "CWE-923",
            "SOC 2 CC6.6 - System Boundaries",
            "NIST SP 800-53 CM-8 - System Component Inventory"
        ],
        references=[
            "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/10-Test_for_Subdomain_Takeover",
            "https://github.com/EdOverflow/can-i-take-over-xyz",
            "https://developer.mozilla.org/en-US/docs/Web/Security/Subdomain_takeovers"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "graphql_vulnerabilities": VulnMeta(
        name="GraphQL Security Vulnerabilities",
        attack_type="graphql_vulnerabilities",
        description="""GraphQL vulnerabilities stem from the flexible query nature of GraphQL 
APIs, which can be exploited for data exposure, denial of service, and injection attacks. 
Common issues include introspection exposure (revealing entire schema), batching attacks 
(brute force via single request), deep nesting DoS (exponentially complex queries), field 
suggestion exploitation, and lack of query cost analysis. Unlike REST, GraphQL clients can 
request any combination of fields, leading to over-fetching of sensitive data. Authorization 
is often implemented at resolver level, leading to inconsistent access control. IDOR vulnerabilities 
are common when IDs in arguments aren't properly authorized. SQL/NoSQL injection can occur 
through improperly handled query arguments.""",
        owasp_category="A01:2021 - Broken Access Control",
        cwe_id="CWE-200",
        cwe_name="Exposure of Sensitive Information to an Unauthorized Actor",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Schema disclosure - Full API structure revealed via introspection
• Data over-fetching - Access more data than intended
• Brute force - Credential stuffing via query batching
• DoS - Resource exhaustion through nested queries
• IDOR - Access other users' data via ID manipulation
• SQL/NoSQL injection - Through unsanitized arguments
• Authorization bypass - Inconsistent resolver-level auth
• Information disclosure - Sensitive fields exposed in schema""",
        remediation="""IMMEDIATE ACTIONS:
1. Disable introspection in production
2. Implement query depth limiting
3. Add query complexity/cost analysis
4. Implement field-level authorization

LONG-TERM FIXES:
5. Use persisted/allowlisted queries in production
6. Implement rate limiting per client/query
7. Add batching limits to prevent abuse
8. Use field-level permissions with consistent enforcement
9. Validate and sanitize all query arguments
10. Implement query timeout mechanisms
11. Monitor for unusual query patterns
12. Use GraphQL security tools (graphql-shield, etc.)""",
        compliance=[
            "OWASP Top 10 A01:2021",
            "OWASP API Security Top 10",
            "CWE-200",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 AC-3 - Access Enforcement"
        ],
        references=[
            "https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html",
            "https://portswigger.net/web-security/graphql",
            "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/12-API_Testing/01-Testing_GraphQL"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "api_security": VulnMeta(
        name="API Security Vulnerabilities",
        attack_type="api_security",
        description="""API Security vulnerabilities encompass issues specific to REST, GraphQL, 
and other API implementations. Common vulnerabilities include Broken Object Level Authorization 
(BOLA/IDOR), Broken Authentication (weak tokens, missing expiration), Broken Function Level 
Authorization (accessing admin endpoints), Excessive Data Exposure (returning unnecessary fields), 
Lack of Resources & Rate Limiting, Mass Assignment (accepting unintended fields), Security 
Misconfiguration (verbose errors, missing headers), and Injection. APIs are particularly 
vulnerable because they expose direct access to business logic and data, often with less 
scrutiny than traditional web interfaces. Mobile and SPA applications increase API attack 
surface as all business logic moves server-side.""",
        owasp_category="A01:2021 - Broken Access Control",
        cwe_id="CWE-284",
        cwe_name="Improper Access Control",
        cvss_base=8.0,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Data exposure - Access unauthorized user data
• Account takeover - Exploit weak authentication
• Privilege escalation - Access admin functionality
• Data manipulation - Modify data via mass assignment
• DoS - Exhaust resources without rate limiting
• Injection - SQL/NoSQL/Command via API parameters
• Information disclosure - Verbose errors reveal internals
• Business logic bypass - Circumvent intended workflows""",
        remediation="""IMMEDIATE ACTIONS:
1. Implement proper authentication for all endpoints
2. Add rate limiting and throttling
3. Validate object-level authorization on every request
4. Return only necessary fields in responses

LONG-TERM FIXES:
5. Use API gateways for consistent security controls
6. Implement function-level authorization checks
7. Define strict input validation schemas
8. Use allowlist for accepted request fields (prevent mass assignment)
9. Implement proper error handling without leaking details
10. Deploy API security testing in CI/CD
11. Use OpenAPI/Swagger with security annotations
12. Regular API security audits and penetration testing""",
        compliance=[
            "OWASP API Security Top 10",
            "OWASP Top 10 A01:2021",
            "CWE-284",
            "PCI-DSS 6.5.8 - Improper Access Control",
            "HIPAA §164.312(a)(1) - Access Control",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 AC-3 - Access Enforcement"
        ],
        references=[
            "https://owasp.org/www-project-api-security/",
            "https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html",
            "https://portswigger.net/web-security/api-testing",
            "https://apisecurity.io/"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "csp_bypass": VulnMeta(
        name="Content Security Policy Bypass",
        attack_type="csp_bypass",
        description="""Content Security Policy (CSP) bypass vulnerabilities occur when CSP 
implementations contain weaknesses that allow attackers to execute scripts despite the policy. 
Common bypasses include: unsafe-inline with nonce/hash bypass, JSONP endpoints on whitelisted 
domains, AngularJS sandbox escape on whitelisted CDNs, base-uri injection, script gadgets in 
whitelisted libraries, data: URI exploitation, and policy injection via response splitting. 
Overly permissive policies (unsafe-eval, broad wildcards) provide minimal protection. CSP 
is defense-in-depth against XSS, so bypasses enable XSS exploitation in otherwise protected 
applications. Browser differences in CSP implementation can create additional bypass vectors.""",
        owasp_category="A05:2021 - Security Misconfiguration",
        cwe_id="CWE-1021",
        cwe_name="Improper Restriction of Rendered UI Layers or Frames",
        cvss_base=6.1,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• XSS execution - Bypass CSP to execute injected scripts
• Data theft - Steal session cookies and sensitive data
• Keylogging - Capture user input
• Credential theft - Inject fake login forms
• Session hijacking - Steal authentication tokens
• Malware injection - Load external malicious scripts
• Defacement - Modify page content
• Cryptocurrency mining - Abuse user resources""",
        remediation="""IMMEDIATE ACTIONS:
1. Remove 'unsafe-inline' and 'unsafe-eval' directives
2. Use nonces or hashes instead of unsafe-inline
3. Restrict script-src to specific trusted domains
4. Avoid whitelisting CDNs with JSONP endpoints

LONG-TERM FIXES:
5. Implement strict-dynamic for modern CSP
6. Use CSP reporting to identify violations
7. Audit whitelisted domains for bypass gadgets
8. Implement base-uri 'self' or 'none'
9. Use object-src 'none' to block plugins
10. Test CSP with tools like CSP Evaluator
11. Regular review of CSP as dependencies change
12. Consider using Trusted Types for DOM XSS protection""",
        compliance=[
            "OWASP Top 10 A05:2021",
            "CWE-1021",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SC-18 - Mobile Code"
        ],
        references=[
            "https://portswigger.net/research/bypassing-csp-with-policy-injection",
            "https://csp-evaluator.withgoogle.com/",
            "https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html",
            "https://book.hacktricks.xyz/pentesting-web/content-security-policy-csp-bypass"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "websocket_vulnerabilities": VulnMeta(
        name="WebSocket Security Vulnerabilities",
        attack_type="websocket_vulnerabilities",
        description="""WebSocket vulnerabilities arise from the persistent, bidirectional nature 
of WebSocket connections and often-overlooked security considerations. Common issues include 
Cross-Site WebSocket Hijacking (CSWSH) - similar to CSRF but for WebSockets, lack of origin 
validation allowing unauthorized connections, missing authentication after handshake, injection 
attacks through message handling, denial of service via resource exhaustion, and information 
disclosure through unencrypted connections (ws:// vs wss://). WebSocket connections bypass 
Same-Origin Policy after the initial handshake, and many security tools don't properly 
inspect WebSocket traffic. Real-time applications like chat, trading, and gaming are common 
targets.""",
        owasp_category="A07:2021 - Identification and Authentication Failures",
        cwe_id="CWE-1385",
        cwe_name="Missing Origin Validation in WebSockets",
        cvss_base=7.1,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Session hijacking - CSWSH to access authenticated sessions
• Data theft - Intercept real-time data streams
• Message injection - Send unauthorized messages
• Account takeover - Exploit authentication weaknesses
• DoS - Exhaust server resources via connection flooding
• Information disclosure - Eavesdrop on unencrypted traffic
• Business logic bypass - Manipulate real-time workflows
• Lateral movement - Access internal WebSocket services""",
        remediation="""IMMEDIATE ACTIONS:
1. Validate Origin header on WebSocket handshake
2. Use wss:// (WebSocket Secure) for all connections
3. Implement token-based authentication for WebSockets
4. Re-validate authentication periodically during session

LONG-TERM FIXES:
5. Implement CSRF tokens for WebSocket handshake
6. Add rate limiting on connection and message level
7. Validate and sanitize all incoming messages
8. Implement proper session timeout and cleanup
9. Use connection-level encryption and integrity
10. Monitor for unusual WebSocket patterns
11. Include WebSockets in security testing scope
12. Implement message schema validation""",
        compliance=[
            "OWASP Top 10 A07:2021",
            "CWE-1385",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SC-8 - Transmission Confidentiality"
        ],
        references=[
            "https://portswigger.net/web-security/websockets",
            "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/10-Testing_WebSockets",
            "https://cheatsheetseries.owasp.org/cheatsheets/WebSocket_Security_Cheat_Sheet.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "race_condition": VulnMeta(
        name="Race Condition (TOCTOU)",
        attack_type="race_condition",
        description="""Race condition vulnerabilities occur when applications perform operations 
that depend on timing, allowing attackers to exploit the gap between check and use (Time-Of-Check 
to Time-Of-Use, TOCTOU). Common scenarios include: double-spending by submitting concurrent 
transactions, bypassing rate limits through parallel requests, coupon/voucher reuse, inventory 
exploitation (buying more than available), vote manipulation, and file-based races. Web 
applications are particularly vulnerable due to stateless request handling and parallel 
processing. Modern techniques like single-packet attacks can achieve nanosecond-level timing, 
making previously unexploitable races viable. These vulnerabilities are often missed by 
automated scanners and require specialized testing.""",
        owasp_category="A04:2021 - Insecure Design",
        cwe_id="CWE-362",
        cwe_name="Concurrent Execution using Shared Resource with Improper Synchronization",
        cvss_base=8.1,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Financial fraud - Double-spending, negative balance exploitation
• Inventory bypass - Purchase more items than available
• Rate limit bypass - Exceed limits through concurrency
• Privilege escalation - Race role assignment operations
• Coupon abuse - Reuse single-use vouchers
• Vote manipulation - Submit multiple votes
• Data corruption - Inconsistent state from concurrent updates
• Account takeover - Race password reset operations""",
        remediation="""IMMEDIATE ACTIONS:
1. Implement database-level locking for critical operations
2. Use atomic operations for counter updates
3. Add unique constraints to prevent duplicate entries
4. Implement idempotency keys for financial operations

LONG-TERM FIXES:
5. Use database transactions with appropriate isolation levels
6. Implement optimistic locking with version numbers
7. Use distributed locks for multi-server deployments
8. Add request deduplication based on idempotency keys
9. Implement server-side rate limiting with atomic counters
10. Use message queues for sequential processing
11. Regular testing with race condition tools (Turbo Intruder)
12. Design for eventual consistency where appropriate""",
        compliance=[
            "OWASP Top 10 A04:2021",
            "CWE-362",
            "PCI-DSS 6.5.5 - Improper error handling",
            "SOC 2 CC6.1 - Logical Access",
            "NIST SP 800-53 SI-16 - Memory Protection"
        ],
        references=[
            "https://portswigger.net/research/smashing-the-state-machine",
            "https://owasp.org/www-community/attacks/Testing_for_Race_Conditions",
            "https://cwe.mitre.org/data/definitions/362.html",
            "https://portswigger.net/web-security/race-conditions"
        ],
        attack_vector="network",
        privileges_required="low",
        user_interaction="none"
    ),
    
    # ==========================================================================
    # MOBILE APPLICATION VULNERABILITIES (OWASP Mobile Top 10 2024)
    # ==========================================================================
    
    "hardcoded_secret": VulnMeta(
        name="Hardcoded Secrets and Credentials",
        attack_type="hardcoded_secret",
        description="""Hardcoded secrets occur when developers embed sensitive credentials directly 
in mobile application source code, configuration files, or binary assets. Common examples include 
API keys, database credentials, encryption keys, OAuth secrets, AWS access keys, and private 
certificates. These secrets persist in compiled binaries and can be extracted through reverse 
engineering using tools like jadx, apktool, or Hopper. Mobile apps distributed through app stores 
are particularly vulnerable as attackers can download and analyze any version. Even obfuscated 
code can reveal secrets through string analysis, memory dumps, or dynamic instrumentation with 
Frida. Once extracted, these credentials provide unauthorized access to backend systems, cloud 
resources, third-party APIs, and sensitive data. The risk is amplified when secrets are shared 
across multiple app installations or environments.""",
        owasp_category="M1:2024 - Improper Credential Usage",
        cwe_id="CWE-798",
        cwe_name="Use of Hard-coded Credentials",
        cvss_base=9.1,
        severity="critical",
        disclosure_days=7,
        impact="""CRITICAL IMPACT:
• Backend compromise - Extracted API keys provide direct backend access
• Cloud account takeover - AWS/Azure/GCP keys enable infrastructure control
• Data breach - Database credentials expose all stored user data
• Third-party abuse - API quotas exhausted, costs incurred, service blocked
• Credential reuse - Same secrets often used across environments
• Supply chain attack - Secrets enable attacks on dependent services
• Compliance violation - PCI, HIPAA, SOC 2 requirements violated
• Persistent access - Static credentials remain valid until rotated""",
        remediation="""IMMEDIATE ACTIONS:
1. Rotate ALL exposed credentials immediately
2. Audit logs for unauthorized access using extracted credentials
3. Remove hardcoded secrets from codebase
4. Implement runtime secret retrieval from secure backend

LONG-TERM FIXES:
5. Use secure key management (AWS Secrets Manager, Azure Key Vault, HashiCorp Vault)
6. Implement certificate pinning with dynamic certificate retrieval
7. Use OAuth device flow instead of embedded client secrets
8. Implement app attestation before providing sensitive credentials
9. Use environment-specific secrets with short rotation periods
10. Add pre-commit hooks to detect secrets before they enter VCS
11. Conduct regular secret scanning in CI/CD pipeline
12. Implement ephemeral credentials with automatic expiration""",
        compliance=[
            "OWASP MASVS-STORAGE-1 - Secure credential storage",
            "OWASP Mobile Top 10 M1:2024",
            "PCI-DSS 3.4 - Protect stored cardholder data",
            "PCI-DSS 8.2.1 - Unique authentication credentials",
            "HIPAA 164.312(d) - Authentication requirements",
            "SOC 2 CC6.1 - Logical access controls",
            "NIST SP 800-53 IA-5 - Authenticator Management",
            "ISO 27001 A.9.4.3 - Password management",
            "CWE-798"
        ],
        references=[
            "https://mas.owasp.org/MASVS/controls/MASVS-STORAGE-1/",
            "https://mobile-security.gitbook.io/masvs/security-requirements/0x07-v2-data_storage_and_privacy_requirements",
            "https://cwe.mitre.org/data/definitions/798.html",
            "https://owasp.org/www-project-mobile-top-10/"
        ],
        attack_vector="local",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "insecure_data_storage": VulnMeta(
        name="Insecure Data Storage",
        attack_type="insecure_data_storage",
        description="""Insecure data storage vulnerabilities occur when mobile applications store 
sensitive information without adequate protection on the device. This includes storing data in 
plaintext files, SharedPreferences (Android), NSUserDefaults (iOS), SQLite databases, or external 
storage accessible by other apps. Sensitive data such as authentication tokens, personal information, 
financial data, or session identifiers may be exposed through local file system access, backup 
extraction, or device theft. Android's external storage is world-readable, and even internal storage 
can be accessed on rooted devices. iOS Keychain provides secure storage but is often underutilized. 
Cloud backup services (iCloud, Google Drive) may inadvertently sync sensitive local data. Log files, 
crash reports, and clipboard data also frequently contain sensitive information that persists 
longer than intended.""",
        owasp_category="M9:2024 - Insecure Data Storage",
        cwe_id="CWE-312",
        cwe_name="Cleartext Storage of Sensitive Information",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Data theft - Sensitive user data extracted from device storage
• Identity theft - Personal information used for fraud
• Session hijacking - Stored tokens provide unauthorized access
• Privacy violation - Personal data exposed without consent
• Credential theft - Stored passwords enable account takeover
• Compliance breach - Regulated data stored improperly
• Backup exposure - Sensitive data synced to cloud backups
• Forensic exposure - Deleted data recoverable from storage""",
        remediation="""IMMEDIATE ACTIONS:
1. Audit all local data storage for sensitive information
2. Encrypt sensitive data using platform-secure storage
3. Use Android EncryptedSharedPreferences or Keystore
4. Use iOS Keychain for credentials and sensitive tokens

LONG-TERM FIXES:
5. Implement data classification scheme for storage decisions
6. Minimize local data storage - prefer server-side storage
7. Implement secure data lifecycle with proper cleanup
8. Exclude sensitive files from backup (android:allowBackup="false")
9. Use iOS Data Protection API with appropriate protection classes
10. Implement secure file deletion (overwrite before delete)
11. Clear clipboard after sensitive operations
12. Disable logging of sensitive data in release builds""",
        compliance=[
            "OWASP MASVS-STORAGE-1 - Secure storage",
            "OWASP MASVS-STORAGE-2 - Data protection",
            "OWASP Mobile Top 10 M9:2024",
            "PCI-DSS 3.4 - Render PAN unreadable",
            "HIPAA 164.312(a)(2)(iv) - Encryption",
            "GDPR Article 32 - Security of processing",
            "SOC 2 CC6.1 - Logical access controls",
            "NIST SP 800-53 SC-28 - Protection of Information at Rest",
            "CWE-312"
        ],
        references=[
            "https://mas.owasp.org/MASVS/controls/MASVS-STORAGE-2/",
            "https://developer.android.com/training/articles/keystore",
            "https://developer.apple.com/documentation/security/keychain_services",
            "https://cwe.mitre.org/data/definitions/312.html"
        ],
        attack_vector="local",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "weak_cryptography": VulnMeta(
        name="Insufficient Cryptography",
        attack_type="weak_cryptography",
        description="""Weak cryptography vulnerabilities in mobile apps involve the use of 
deprecated, broken, or improperly implemented cryptographic algorithms. Common issues include 
using MD5/SHA1 for password hashing, DES/3DES/RC4 for encryption, weak RSA key sizes (<2048 bits), 
ECB mode for block ciphers, hardcoded initialization vectors, predictable random number generation, 
and improper key derivation. Mobile platforms may use insecure default algorithms, and developers 
often implement custom cryptography that fails to meet security standards. Even strong algorithms 
become vulnerable through poor implementation: reusing nonces in GCM mode, CBC without HMAC, 
or using same key for encryption and authentication. Cryptographic failures can lead to data 
exposure, authentication bypass, and complete compromise of confidentiality guarantees. Legacy 
compatibility requirements often perpetuate use of weak algorithms.""",
        owasp_category="M10:2024 - Insufficient Cryptography",
        cwe_id="CWE-327",
        cwe_name="Use of a Broken or Risky Cryptographic Algorithm",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Data decryption - Weak ciphers broken through cryptanalysis
• Password cracking - Weak hash algorithms enable rapid brute force
• Authentication bypass - Predictable tokens through weak RNG
• Key recovery - Short keys vulnerable to exhaustive search
• Replay attacks - Missing or predictable IVs enable replay
• Integrity violation - Missing MAC allows undetected modification
• Regulatory non-compliance - Use of deprecated algorithms
• Future exposure - Data encrypted today decrypted tomorrow""",
        remediation="""IMMEDIATE ACTIONS:
1. Replace MD5/SHA1 with SHA-256 or SHA-3 for hashing
2. Replace DES/3DES/RC4 with AES-256-GCM for encryption
3. Use minimum 2048-bit RSA or 256-bit ECC keys
4. Implement proper random IV generation for each encryption

LONG-TERM FIXES:
5. Use platform cryptographic APIs (Android Keystore, iOS CryptoKit)
6. Implement proper key derivation (Argon2, PBKDF2 with high iterations)
7. Use authenticated encryption (AES-GCM, ChaCha20-Poly1305)
8. Implement cryptographic agility for future algorithm updates
9. Never implement custom cryptographic algorithms
10. Use hardware-backed key storage when available
11. Implement proper key rotation procedures
12. Conduct cryptographic code review by specialists""",
        compliance=[
            "OWASP MASVS-CRYPTO-1 - Strong cryptography",
            "OWASP MASVS-CRYPTO-2 - Cryptographic implementation",
            "OWASP Mobile Top 10 M10:2024",
            "PCI-DSS 3.5 - Protect encryption keys",
            "PCI-DSS 4.1 - Strong cryptography for transmission",
            "HIPAA 164.312(a)(2)(iv) - Encryption mechanism",
            "NIST SP 800-175B - Cryptographic standards",
            "FIPS 140-2 - Cryptographic module requirements",
            "CWE-327"
        ],
        references=[
            "https://mas.owasp.org/MASVS/controls/MASVS-CRYPTO-1/",
            "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html",
            "https://cwe.mitre.org/data/definitions/327.html",
            "https://www.keylength.com/en/compare/"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "insecure_network_communication": VulnMeta(
        name="Insecure Network Communication",
        attack_type="insecure_network_communication",
        description="""Insecure network communication vulnerabilities occur when mobile apps 
transmit sensitive data without proper transport layer protection. This includes using plain HTTP, 
accepting invalid SSL/TLS certificates, disabling certificate validation, using deprecated protocols 
(SSLv3, TLS 1.0/1.1), weak cipher suites, and missing certificate pinning. Man-in-the-middle (MITM) 
attacks on public WiFi networks can intercept credentials, session tokens, and personal data. 
Android's Network Security Configuration and iOS's App Transport Security (ATS) enforce HTTPS, 
but developers often disable these protections for convenience. Even with HTTPS, missing certificate 
pinning allows attackers with CA-signed certificates to intercept traffic. WebViews may bypass 
app-level security configurations. Third-party SDKs and ad networks may introduce insecure 
connections that compromise the entire app's security posture.""",
        owasp_category="M5:2024 - Insecure Communication",
        cwe_id="CWE-319",
        cwe_name="Cleartext Transmission of Sensitive Information",
        cvss_base=8.1,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Credential theft - Intercepted login credentials on public networks
• Session hijacking - Captured tokens enable account access
• Data interception - Sensitive data read during transmission
• Man-in-the-middle - Traffic modified in transit
• Privacy violation - Personal information exposed to eavesdroppers
• API key theft - Intercepted keys enable unauthorized API access
• Injection attacks - MITM enables payload injection
• Compliance violation - Transmission security requirements breached""",
        remediation="""IMMEDIATE ACTIONS:
1. Enforce HTTPS for all network communications
2. Enable Android Network Security Configuration
3. Enable iOS App Transport Security (remove ATS exceptions)
4. Validate SSL/TLS certificates properly

LONG-TERM FIXES:
5. Implement certificate pinning for sensitive endpoints
6. Use TLS 1.2+ with strong cipher suites only
7. Implement proper certificate validation callbacks
8. Use platform HTTP clients with secure defaults
9. Audit third-party SDKs for insecure connections
10. Implement network security testing in CI/CD
11. Use mutual TLS for high-security APIs
12. Monitor for certificate transparency logs""",
        compliance=[
            "OWASP MASVS-NETWORK-1 - TLS for all connections",
            "OWASP MASVS-NETWORK-2 - TLS configuration",
            "OWASP Mobile Top 10 M5:2024",
            "PCI-DSS 4.1 - Strong cryptography for transmission",
            "PCI-DSS 4.2 - Secure transmission channels",
            "HIPAA 164.312(e)(1) - Transmission security",
            "GDPR Article 32 - Encryption in transit",
            "NIST SP 800-52 - TLS implementation guidelines",
            "CWE-319"
        ],
        references=[
            "https://mas.owasp.org/MASVS/controls/MASVS-NETWORK-1/",
            "https://developer.android.com/training/articles/security-config",
            "https://developer.apple.com/documentation/security/preventing_insecure_network_connections",
            "https://cwe.mitre.org/data/definitions/319.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "webview_vulnerability": VulnMeta(
        name="WebView Vulnerabilities",
        attack_type="webview_vulnerability",
        description="""WebView vulnerabilities arise from insecure configuration of embedded 
browser components in mobile applications. WebViews execute web content within the app context 
and can access native device capabilities through JavaScript bridges. Common issues include 
enabling JavaScript in WebViews loading untrusted content, exposed addJavascriptInterface methods 
(allowing arbitrary code execution on Android <4.2), loading content over HTTP, disabled SSL 
error handling, file:// URL access, universal XSS through JavaScript injection, and insecure 
deeplink handling. Attackers can inject malicious scripts through MITM, compromised web servers, 
or crafted URLs. Once JavaScript executes in the WebView context, it may access app data, invoke 
native methods, read files, or manipulate the user interface. WebViews often have weaker security 
than standalone browsers, missing sandboxing and content security policies.""",
        owasp_category="M4:2024 - Insufficient Input/Output Validation",
        cwe_id="CWE-749",
        cwe_name="Exposed Dangerous Method or Function",
        cvss_base=8.8,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Remote code execution - JavaScript bridge exploitation
• Data theft - Access to app sandbox data through file:// URLs
• Session hijacking - Stolen cookies and tokens from WebView
• Phishing - Fake login forms in trusted app context
• Native method invocation - Exposed interfaces enable device access
• Cross-site scripting - XSS in WebView context
• Local file access - Reading sensitive app files
• MITM exploitation - HTTP content injection into WebView""",
        remediation="""IMMEDIATE ACTIONS:
1. Disable JavaScript if not required for functionality
2. Remove @JavascriptInterface methods or limit exposed APIs
3. Enforce HTTPS-only content loading
4. Implement proper SSL certificate validation

LONG-TERM FIXES:
5. Use setAllowFileAccess(false) to block file:// URLs
6. Implement Content-Security-Policy for WebView content
7. Use shouldOverrideUrlLoading to validate all URLs
8. Whitelist allowed JavaScript bridge methods
9. Sanitize all data passed to JavaScript
10. Use Chrome Custom Tabs or SFSafariViewController for web content
11. Implement WebView security headers
12. Regular security testing of WebView implementations""",
        compliance=[
            "OWASP MASVS-PLATFORM-2 - WebView security",
            "OWASP MASVS-CODE-4 - Input validation",
            "OWASP Mobile Top 10 M4:2024",
            "CWE-749 - Exposed dangerous methods",
            "CWE-79 - Cross-site scripting",
            "SOC 2 CC6.1 - Logical access controls",
            "NIST SP 800-53 SI-10 - Information Input Validation"
        ],
        references=[
            "https://mas.owasp.org/MASVS/controls/MASVS-PLATFORM-2/",
            "https://developer.android.com/guide/webapps/webview",
            "https://owasp.org/www-community/attacks/Mobile_WebView_Attack",
            "https://cwe.mitre.org/data/definitions/749.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "intent_injection": VulnMeta(
        name="Intent/IPC Injection (Android)",
        attack_type="intent_injection",
        description="""Intent injection vulnerabilities occur when Android applications process 
untrusted data in Intent handling without proper validation. Intents are the primary inter-process 
communication (IPC) mechanism in Android, and exported components (Activities, Services, Broadcast 
Receivers, Content Providers) can receive Intents from any app. Attackers craft malicious Intents 
containing unexpected extras, URIs, or actions to manipulate app behavior. Vulnerable patterns 
include parsing untrusted Intent data for file paths (leading to arbitrary file access), using 
Intent extras in SQL queries (SQL injection), reflecting Intent data in WebViews (XSS), or passing 
untrusted Intents to startActivity without validation (privilege escalation). Implicit Intents 
can be intercepted by malicious apps, and exported components without permission protection are 
accessible system-wide. PendingIntents with FLAG_MUTABLE allow Intent modification by receivers.""",
        owasp_category="M1:2024 - Improper Platform Usage",
        cwe_id="CWE-926",
        cwe_name="Improper Export of Android Application Components",
        cvss_base=7.8,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Privilege escalation - Access protected functionality through Intent manipulation
• Data theft - Access Content Providers with path traversal
• SQL injection - Untrusted Intent data in database queries
• Arbitrary file access - Manipulated file:// URIs in Intents
• Cross-site scripting - Intent data reflected in WebViews
• Service abuse - Trigger unintended service operations
• PendingIntent hijacking - Modify mutable PendingIntents
• Denial of service - Crash through malformed Intent data""",
        remediation="""IMMEDIATE ACTIONS:
1. Set android:exported="false" for internal components
2. Add permission requirements for exported components
3. Validate all Intent extras before use
4. Use explicit Intents for internal communication

LONG-TERM FIXES:
5. Implement input validation for Intent data
6. Use PendingIntent.FLAG_IMMUTABLE for PendingIntents
7. Sanitize file paths from Intent URIs
8. Avoid passing untrusted data to WebViews from Intents
9. Use signature-level permissions for sensitive components
10. Implement Content Provider URI permissions
11. Validate caller identity using getCallingUid()
12. Use LocalBroadcastManager for internal broadcasts""",
        compliance=[
            "OWASP MASVS-PLATFORM-1 - Platform permissions",
            "OWASP Mobile Top 10 M1:2024",
            "CWE-926 - Improper component export",
            "CWE-927 - Improper implicit intent use",
            "Android Security Best Practices",
            "SOC 2 CC6.1 - Logical access controls",
            "NIST SP 800-53 AC-3 - Access enforcement"
        ],
        references=[
            "https://mas.owasp.org/MASVS/controls/MASVS-PLATFORM-1/",
            "https://developer.android.com/guide/components/intents-filters",
            "https://cwe.mitre.org/data/definitions/926.html",
            "https://developer.android.com/training/articles/security-tips"
        ],
        attack_vector="local",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "url_scheme_hijacking": VulnMeta(
        name="URL Scheme Hijacking",
        attack_type="url_scheme_hijacking",
        description="""URL scheme hijacking occurs when mobile applications implement insecure 
custom URL handlers that can be exploited by malicious apps or websites. On iOS, non-Universal 
Links can be claimed by any app, allowing attackers to intercept deeplinks intended for legitimate 
apps. On Android, Intent filters with custom schemes can be registered by multiple apps, creating 
race conditions. Attackers register the same URL scheme to intercept OAuth callbacks, password 
reset links, or authentication tokens. Beyond hijacking, improper URL scheme handling can lead 
to code execution when apps process untrusted parameters from deeplinks. Webpages can trigger 
URL schemes through iframes, redirects, or JavaScript, enabling remote exploitation. Universal 
Links (iOS) and App Links (Android) mitigate hijacking through domain verification but are 
often implemented alongside vulnerable custom schemes for backward compatibility.""",
        owasp_category="M1:2024 - Improper Platform Usage",
        cwe_id="CWE-939",
        cwe_name="Improper Authorization in Handler for Custom URL Scheme",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• OAuth token theft - Intercepted authorization codes
• Session hijacking - Captured authentication callbacks
• Phishing - Fake apps handling legitimate links
• Account takeover - Stolen password reset tokens
• Command injection - Malicious parameters in deeplinks
• Data theft - Sensitive data passed through URL parameters
• Privilege escalation - Admin links handled by malicious app
• Payment fraud - Intercepted payment confirmation deeplinks""",
        remediation="""IMMEDIATE ACTIONS:
1. Validate all parameters received through URL schemes
2. Never pass sensitive tokens through URL schemes
3. Implement state parameters for OAuth flows
4. Use Universal Links (iOS) and App Links (Android)

LONG-TERM FIXES:
5. Implement domain association files (apple-app-site-association, assetlinks.json)
6. Require HTTPS for callback URLs
7. Add nonce validation for sensitive operations
8. Implement additional user confirmation for sensitive actions
9. Use system browsers with proper redirect validation
10. Audit all URL scheme handlers for injection vulnerabilities
11. Remove legacy custom schemes after Universal/App Links adoption
12. Implement rate limiting on sensitive URL handlers""",
        compliance=[
            "OWASP MASVS-PLATFORM-1 - Platform permissions",
            "OWASP Mobile Top 10 M1:2024",
            "CWE-939 - Custom URL scheme authorization",
            "OAuth 2.0 Security Best Current Practice",
            "SOC 2 CC6.1 - Logical access controls",
            "PCI-DSS 8.2 - Authentication management"
        ],
        references=[
            "https://mas.owasp.org/MASVS/controls/MASVS-PLATFORM-1/",
            "https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content",
            "https://developer.android.com/training/app-links",
            "https://cwe.mitre.org/data/definitions/939.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="required"
    ),
    
    "binary_protection": VulnMeta(
        name="Insufficient Binary Protection",
        attack_type="binary_protection",
        description="""Insufficient binary protection refers to mobile applications lacking 
adequate defenses against reverse engineering and code tampering. Without protection, attackers 
can decompile apps using tools like jadx, apktool, Hopper, or IDA Pro to extract business logic, 
cryptographic keys, API endpoints, and authentication mechanisms. They can then repackage modified 
apps with malware, bypass license checks, remove ads, or create pirated versions. Debug symbols, 
verbose logging, and readable string literals facilitate reverse engineering. Missing code 
obfuscation, root/jailbreak detection, debugger detection, and integrity verification leave apps 
vulnerable to runtime manipulation using Frida, Xposed, or Cycript. While client-side protections 
can be bypassed by determined attackers, they increase the cost and effort required, deterring 
casual attackers and automated tools. Defense in depth requires layered protections.""",
        owasp_category="M8:2024 - Security Misconfiguration",
        cwe_id="CWE-693",
        cwe_name="Protection Mechanism Failure",
        cvss_base=5.3,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• Intellectual property theft - Business logic reverse engineered
• Secret extraction - Hardcoded credentials discovered
• License bypass - Paid features unlocked
• Malware injection - Trojanized apps redistributed
• Ad removal - Revenue stream bypassed
• Debugging exploitation - Runtime manipulation attacks
• Credential harvesting - Modified apps steal user data
• Brand damage - Fake/modified apps damage reputation""",
        remediation="""IMMEDIATE ACTIONS:
1. Enable code obfuscation (ProGuard/R8 for Android)
2. Remove debug symbols and verbose logging from release builds
3. Implement basic integrity verification
4. Enable android:debuggable="false" in production

LONG-TERM FIXES:
5. Implement root/jailbreak detection
6. Add debugger and emulator detection
7. Use native code (NDK/Swift) for sensitive operations
8. Implement certificate pinning with runtime validation
9. Use commercial RASP (Runtime Application Self-Protection)
10. Implement code attestation with backend verification
11. Monitor app stores for repackaged versions
12. Layer multiple protection mechanisms for defense in depth""",
        compliance=[
            "OWASP MASVS-RESILIENCE-1 - Reverse engineering prevention",
            "OWASP MASVS-RESILIENCE-2 - Anti-tampering",
            "OWASP MASVS-RESILIENCE-3 - Anti-debugging",
            "OWASP Mobile Top 10 M8:2024",
            "CWE-693 - Protection mechanism failure",
            "PCI-DSS 5.1 - Protect against malware",
            "SOC 2 CC6.8 - System operations monitoring"
        ],
        references=[
            "https://mas.owasp.org/MASVS/controls/MASVS-RESILIENCE-1/",
            "https://developer.android.com/studio/build/shrink-code",
            "https://owasp.org/www-project-mobile-top-10/",
            "https://cwe.mitre.org/data/definitions/693.html"
        ],
        attack_vector="local",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "ios_ats_bypass": VulnMeta(
        name="iOS App Transport Security Bypass",
        attack_type="ios_ats_bypass",
        description="""App Transport Security (ATS) is iOS's built-in mechanism enforcing secure 
HTTPS connections with modern TLS requirements. ATS bypass vulnerabilities occur when developers 
disable these protections through Info.plist exceptions. Common bypasses include NSAllowsArbitraryLoads 
(disables ATS entirely), NSExceptionAllowsInsecureHTTPLoads (allows HTTP for specific domains), 
NSExceptionMinimumTLSVersion (allows deprecated TLS versions), and NSExceptionRequiresForwardSecrecy 
(disables PFS requirement). While some bypasses are legitimate (e.g., media streaming, compatibility 
with legacy servers), they create security gaps exploitable through man-in-the-middle attacks. 
Third-party SDKs and ad networks often require ATS exceptions, introducing vulnerabilities. Apple 
reviews ATS exceptions during App Store submission, but many pass through. Even targeted exceptions 
for specific domains weaken security if those domains are compromised or targeted.""",
        owasp_category="M5:2024 - Insecure Communication",
        cwe_id="CWE-319",
        cwe_name="Cleartext Transmission of Sensitive Information",
        cvss_base=7.5,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Man-in-the-middle attacks - Traffic interception on public networks
• Credential theft - Login credentials captured over HTTP
• Session hijacking - Session tokens intercepted in transit
• Data exposure - Sensitive user data transmitted insecurely
• API key theft - Unencrypted API communications exposed
• Content injection - Malicious content injected through MITM
• Privacy violation - Personal data exposed to eavesdroppers
• Regulatory non-compliance - Transmission security requirements violated""",
        remediation="""IMMEDIATE ACTIONS:
1. Remove NSAllowsArbitraryLoads from Info.plist
2. Audit all NSExceptionDomains for necessity
3. Update backend servers to support TLS 1.2+ with strong ciphers
4. Replace HTTP endpoints with HTTPS equivalents

LONG-TERM FIXES:
5. Implement certificate pinning for sensitive connections
6. Audit third-party SDKs for ATS exception requirements
7. Use NSAllowsLocalNetworking only for local development
8. Document business justification for any remaining exceptions
9. Implement network security monitoring
10. Test ATS compliance with Apple's nscurl diagnostic tool
11. Use CDN providers with strong TLS support
12. Plan migration timeline for legacy server upgrades""",
        compliance=[
            "OWASP MASVS-NETWORK-1 - TLS for all connections",
            "OWASP Mobile Top 10 M5:2024",
            "Apple App Store Review Guidelines",
            "PCI-DSS 4.1 - Strong cryptography for transmission",
            "HIPAA 164.312(e)(1) - Transmission security",
            "SOC 2 CC6.7 - Transmission integrity",
            "CWE-319"
        ],
        references=[
            "https://developer.apple.com/documentation/security/preventing_insecure_network_connections",
            "https://mas.owasp.org/MASVS/controls/MASVS-NETWORK-1/",
            "https://developer.apple.com/library/archive/technotes/tn2232/_index.html",
            "https://cwe.mitre.org/data/definitions/319.html"
        ],
        attack_vector="network",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "debuggable_application": VulnMeta(
        name="Debuggable Application",
        attack_type="debuggable_application",
        description="""A debuggable application is a mobile app released with debugging capabilities 
enabled, allowing attackers to attach debuggers, inspect runtime state, and modify application 
behavior. On Android, android:debuggable="true" in AndroidManifest.xml allows JDWP (Java Debug 
Wire Protocol) connections from any source. On iOS, get-task-allow entitlement enables debugging 
in development builds. Debuggable apps allow attackers to: set breakpoints at security-critical 
code, bypass authentication checks at runtime, extract encryption keys from memory, modify method 
return values, inject malicious code, and dump sensitive data structures. Runtime instrumentation 
tools like Frida benefit from debuggable targets. This vulnerability is particularly severe because 
it bypasses most static protections - even encrypted data must be decrypted in memory where 
debuggers can access it. Release builds should never have debugging enabled.""",
        owasp_category="M8:2024 - Security Misconfiguration",
        cwe_id="CWE-489",
        cwe_name="Active Debug Code",
        cvss_base=7.1,
        severity="high",
        disclosure_days=21,
        impact="""HIGH IMPACT:
• Runtime manipulation - Debugger modifies app behavior
• Authentication bypass - Skip security checks via breakpoints
• Memory inspection - Extract keys and secrets from RAM
• Method hooking - Intercept and modify function returns
• Code injection - Insert malicious code at runtime
• Complete app compromise - Full control over app execution
• Data extraction - Dump all in-memory sensitive data
• Logic bypass - Circumvent license, payment, or access checks""",
        remediation="""IMMEDIATE ACTIONS:
1. Set android:debuggable="false" in AndroidManifest.xml
2. Remove get-task-allow entitlement from iOS release builds
3. Use release build configurations with debugging disabled
4. Verify build settings before app store submission

LONG-TERM FIXES:
5. Implement CI/CD checks for debuggable flags
6. Add runtime debugger detection
7. Use ProGuard/R8 optimization in release builds
8. Implement anti-tampering checks
9. Test release builds for debugging capabilities
10. Use app signing with release keystores only
11. Implement Frida/Xposed detection
12. Consider commercial RASP solutions for critical apps""",
        compliance=[
            "OWASP MASVS-RESILIENCE-3 - Anti-debugging",
            "OWASP Mobile Top 10 M8:2024",
            "CWE-489 - Active debug code",
            "PCI-DSS 6.5.8 - Improper access control",
            "SOC 2 CC6.1 - Logical access controls",
            "NIST SP 800-53 CM-7 - Least functionality"
        ],
        references=[
            "https://developer.android.com/guide/topics/manifest/application-element#debug",
            "https://mas.owasp.org/MASVS/controls/MASVS-RESILIENCE-3/",
            "https://cwe.mitre.org/data/definitions/489.html",
            "https://owasp.org/www-project-mobile-top-10/"
        ],
        attack_vector="local",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "root_jailbreak_detection_bypass": VulnMeta(
        name="Root/Jailbreak Detection Bypass",
        attack_type="root_jailbreak_detection_bypass",
        description="""Root/jailbreak detection bypass vulnerabilities occur when mobile applications 
either lack detection for compromised device environments or implement easily circumvented checks. 
Rooted Android devices and jailbroken iOS devices have elevated privileges that bypass normal 
security controls: apps can be modified, traffic intercepted, keystrokes logged, and sandboxes 
escaped. Banking, healthcare, and enterprise apps often implement root/jailbreak detection as a 
security control, but common detection methods are well-documented and easily bypassed. Attackers 
use tools like Magisk (systemless root hiding), Liberty Lite, or custom Frida scripts to bypass 
checks. Detection often relies on file existence checks, app lists, or system properties that can 
be spoofed. Robust detection requires multiple layered checks, native code implementation, and 
server-side verification, though determined attackers can eventually bypass any client-side check.""",
        owasp_category="M8:2024 - Security Misconfiguration",
        cwe_id="CWE-919",
        cwe_name="Weaknesses in Mobile Applications",
        cvss_base=6.5,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• Security control bypass - App runs on compromised devices
• Sandbox escape - Other apps can access app data
• Traffic interception - All HTTPS traffic readable on device
• Keylogging - Credentials captured by malicious apps
• Runtime manipulation - App behavior modified by root tools
• Data theft - App sandbox fully accessible to attackers
• Fraud enablement - Banking/payment controls circumvented
• Compliance violation - Apps on non-compliant devices""",
        remediation="""IMMEDIATE ACTIONS:
1. Implement basic root/jailbreak detection checks
2. Check for common root indicators (su binary, Magisk, Cydia)
3. Verify system partition integrity
4. Check for hook frameworks (Frida, Xposed, Substrate)

LONG-TERM FIXES:
5. Implement detection in native code (harder to bypass)
6. Use multiple detection methods in combination
7. Implement server-side device attestation (SafetyNet/Play Integrity, DeviceCheck)
8. Add runtime integrity verification
9. Implement behavioral analysis for anomalies
10. Update detection regularly as bypass methods evolve
11. Consider commercial RASP solutions
12. Implement graduated responses (warn, limit features, block)""",
        compliance=[
            "OWASP MASVS-RESILIENCE-1 - Root/jailbreak detection",
            "OWASP Mobile Top 10 M8:2024",
            "PCI-DSS 5.1 - Protect against malware",
            "HIPAA 164.312(a)(1) - Access control",
            "SOC 2 CC6.1 - Logical access controls",
            "CWE-919"
        ],
        references=[
            "https://mas.owasp.org/MASVS/controls/MASVS-RESILIENCE-1/",
            "https://developer.android.com/training/safetynet",
            "https://developer.apple.com/documentation/devicecheck",
            "https://owasp.org/www-project-mobile-top-10/"
        ],
        attack_vector="local",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "clipboard_data_exposure": VulnMeta(
        name="Clipboard Data Exposure",
        attack_type="clipboard_data_exposure",
        description="""Clipboard data exposure occurs when mobile applications copy sensitive 
information to the system clipboard without proper protection or cleanup. The clipboard is a 
shared system resource accessible by all applications, meaning any app can read copied content. 
Sensitive data commonly exposed includes passwords, credit card numbers, one-time passwords, 
API keys, session tokens, and personal information. On iOS 14+, clipboard access triggers a 
notification, but earlier versions and Android provide silent access. Some apps implement 
clipboard managers that continuously monitor and store clipboard contents. Password managers, 
banking apps, and authentication apps are particularly vulnerable when users copy credentials. 
Clipboard data may also sync across devices via cloud services, extending exposure beyond the 
local device. Background apps can monitor clipboard changes in real-time.""",
        owasp_category="M9:2024 - Insecure Data Storage",
        cwe_id="CWE-200",
        cwe_name="Exposure of Sensitive Information to an Unauthorized Actor",
        cvss_base=5.5,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• Credential theft - Copied passwords accessible to other apps
• Token exposure - Session tokens readable from clipboard
• Financial data leak - Credit card numbers copied insecurely
• OTP interception - One-time passwords captured by malicious apps
• Cross-device exposure - Clipboard synced to other devices
• Persistent exposure - Clipboard contents remain after app closes
• Privacy violation - Personal data shared unintentionally
• Chain attacks - Clipboard data enables further attacks""",
        remediation="""IMMEDIATE ACTIONS:
1. Avoid copying sensitive data to clipboard when possible
2. Implement clipboard timeout to clear sensitive data
3. Use secure text fields that prevent copying (on Android)
4. Warn users when sensitive data is copied

LONG-TERM FIXES:
5. Implement in-app secure sharing instead of clipboard
6. Use UIPasteboard.general.setItems with expiration (iOS)
7. Clear clipboard when app moves to background
8. Implement secure input methods that don't use clipboard
9. Use ClipData with sensitive flag (Android 13+)
10. Monitor clipboard access in security-critical sections
11. Educate users about clipboard security risks
12. Consider autofill APIs as alternative to copy/paste""",
        compliance=[
            "OWASP MASVS-STORAGE-2 - Data protection",
            "OWASP Mobile Top 10 M9:2024",
            "CWE-200 - Information exposure",
            "GDPR Article 32 - Security of processing",
            "HIPAA 164.312(a)(1) - Access control",
            "SOC 2 CC6.1 - Logical access controls"
        ],
        references=[
            "https://mas.owasp.org/MASVS/controls/MASVS-STORAGE-2/",
            "https://developer.android.com/about/versions/13/behavior-changes-13#copy-sensitive-content",
            "https://developer.apple.com/documentation/uikit/uipasteboard",
            "https://cwe.mitre.org/data/definitions/200.html"
        ],
        attack_vector="local",
        privileges_required="low",
        user_interaction="required"
    ),
    
    "backup_data_exposure": VulnMeta(
        name="Backup Data Exposure",
        attack_type="backup_data_exposure",
        description="""Backup data exposure vulnerabilities occur when mobile applications allow 
sensitive data to be included in device backups without adequate protection. Android apps with 
android:allowBackup="true" (default) have their data included in ADB backups and cloud backups 
(Google Drive). iOS apps include data in iCloud and iTunes backups unless excluded. Attackers 
with physical access or compromised backup services can extract app data including databases, 
preferences, cached credentials, and encryption keys. Backup files are often stored without the 
same protections as live device storage. Enterprise MDM solutions may create additional backup 
vectors. Auto-backup features sync data across devices, potentially exposing it on less-secure 
secondary devices. Even encrypted backups can be vulnerable if the backup password is weak or 
if the encryption is device-specific and bypassed through backup manipulation.""",
        owasp_category="M9:2024 - Insecure Data Storage",
        cwe_id="CWE-530",
        cwe_name="Exposure of Backup File to an Unauthorized Control Sphere",
        cvss_base=6.8,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• Data extraction - Sensitive data pulled from backup files
• Credential theft - Stored passwords extracted from backups
• Token recovery - Authentication tokens accessible in backups
• Privacy breach - Personal data exposed through backup access
• Cross-device exposure - Data synced to less-secure devices
• Forensic vulnerability - Deleted data recoverable from backups
• Cloud exposure - Backup data stored in cloud services
• Compliance violation - Regulated data in uncontrolled backups""",
        remediation="""IMMEDIATE ACTIONS:
1. Set android:allowBackup="false" for sensitive apps
2. Exclude sensitive files using backup rules (Android)
3. Set NSURLIsExcludedFromBackupKey for iOS files
4. Use Keychain with appropriate accessibility flags

LONG-TERM FIXES:
5. Implement Android backup rules XML for selective backup
6. Use iOS Data Protection with NSFileProtectionComplete
7. Store sensitive data in locations excluded from backup
8. Encrypt sensitive data with device-bound keys
9. Implement backup content verification
10. Use android:fullBackupContent to specify inclusions/exclusions
11. Test backup contents for sensitive data exposure
12. Document backup security in security policies""",
        compliance=[
            "OWASP MASVS-STORAGE-1 - Secure storage",
            "OWASP MASVS-STORAGE-2 - Data protection",
            "OWASP Mobile Top 10 M9:2024",
            "CWE-530 - Backup exposure",
            "GDPR Article 32 - Security of processing",
            "HIPAA 164.312(a)(1) - Access control",
            "PCI-DSS 3.4 - Protect stored data"
        ],
        references=[
            "https://developer.android.com/guide/topics/data/autobackup",
            "https://developer.apple.com/documentation/foundation/optimizing_your_app_s_data_for_icloud_backup",
            "https://mas.owasp.org/MASVS/controls/MASVS-STORAGE-2/",
            "https://cwe.mitre.org/data/definitions/530.html"
        ],
        attack_vector="local",
        privileges_required="none",
        user_interaction="none"
    ),
    
    "logging_sensitive_data": VulnMeta(
        name="Sensitive Data in Logs",
        attack_type="logging_sensitive_data",
        description="""Sensitive data logging vulnerabilities occur when mobile applications 
write confidential information to system logs, crash reports, or analytics services. Developers 
often log data for debugging that should never appear in production: passwords, tokens, personal 
information, financial data, and API keys. On Android, logcat is accessible to any app with 
READ_LOGS permission (pre-Android 4.1) or through ADB. iOS logs are accessible through Xcode, 
device management profiles, or crash report services. Crash reports submitted to third-party 
services (Crashlytics, Sentry, Bugsnag) may include sensitive stack traces and variable values. 
Analytics SDKs may inadvertently capture sensitive screen content. Even log rotation doesn't 
immediately delete sensitive data, and logs may be synced to cloud services. Production apps 
should use release log levels and sanitize all logged data.""",
        owasp_category="M9:2024 - Insecure Data Storage",
        cwe_id="CWE-532",
        cwe_name="Insertion of Sensitive Information into Log File",
        cvss_base=5.5,
        severity="medium",
        disclosure_days=45,
        impact="""MEDIUM IMPACT:
• Credential exposure - Passwords logged in debug statements
• Token leakage - Authentication tokens in log files
• PII disclosure - Personal information in crash reports
• API key exposure - Secrets logged during API calls
• Session data leak - Session information in analytics
• Debugging info exposure - Sensitive debugging data in production
• Third-party access - Logs sent to external services
• Forensic discovery - Sensitive data in old log files""",
        remediation="""IMMEDIATE ACTIONS:
1. Audit all logging statements for sensitive data
2. Use release build configurations with minimal logging
3. Remove or obfuscate sensitive values before logging
4. Configure crash reporting to exclude sensitive fields

LONG-TERM FIXES:
5. Implement centralized logging with data sanitization
6. Use log levels appropriately (no DEBUG/VERBOSE in production)
7. Create logging guidelines prohibiting sensitive data
8. Implement automated log scanning in CI/CD
9. Configure ProGuard to remove log calls in release builds
10. Use structured logging with explicit field filtering
11. Review third-party SDK logging configurations
12. Implement log retention policies with secure deletion""",
        compliance=[
            "OWASP MASVS-STORAGE-2 - Data protection",
            "OWASP Mobile Top 10 M9:2024",
            "CWE-532 - Sensitive info in logs",
            "GDPR Article 32 - Security of processing",
            "HIPAA 164.312(d) - Audit controls",
            "PCI-DSS 3.4 - Protect stored data",
            "SOC 2 CC6.1 - Logical access controls"
        ],
        references=[
            "https://mas.owasp.org/MASVS/controls/MASVS-STORAGE-2/",
            "https://developer.android.com/reference/android/util/Log",
            "https://developer.apple.com/documentation/os/logging",
            "https://cwe.mitre.org/data/definitions/532.html"
        ],
        attack_vector="local",
        privileges_required="none",
        user_interaction="none"
    ),
}


# =============================================================================
# ATTACK TYPE ALIASES
# Maps scanner attack_type values to registry keys for consistency
# =============================================================================

ATTACK_TYPE_ALIASES = {
    # Command Injection aliases
    "command_injection": "cmdi",
    "os_command_injection": "cmdi",
    "shell_injection": "cmdi",
    
    # NoSQL Injection aliases
    "nosql_injection": "nosql",
    "mongodb_injection": "nosql",
    
    # Cache Poisoning aliases
    "cache_poisoning": "web_cache_poisoning",
    "http_cache_poisoning": "web_cache_poisoning",
    
    # Deserialization aliases
    "deserialization": "insecure_deserialization",
    "unsafe_deserialization": "insecure_deserialization",
    "java_deserialization": "insecure_deserialization",
    "php_deserialization": "insecure_deserialization",
    "pickle_deserialization": "insecure_deserialization",
    
    # CRLF aliases
    "http_response_splitting": "crlf_injection",
    "header_injection": "crlf_injection",
    
    # Other common aliases
    "sql_injection": "sqli",
    "cross_site_scripting": "xss",
    "reflected_xss": "xss",
    "stored_xss": "xss",
    "dom_xss": "xss",
    "template_injection": "ssti",
    "server_side_template_injection": "ssti",
}


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def get_vuln_meta(attack_type: str) -> Optional[VulnMeta]:
    """
    Get vulnerability metadata by attack type.
    
    Supports aliases for common attack type variations used by different scanners.
    
    Args:
        attack_type: Internal attack type identifier (e.g., "sqli", "xss", "command_injection")
        
    Returns:
        VulnMeta instance or None if not found
    """
    attack_type_lower = attack_type.lower()
    
    # First try direct lookup
    if attack_type_lower in VULN_REGISTRY:
        return VULN_REGISTRY[attack_type_lower]
    
    # Try alias lookup
    if attack_type_lower in ATTACK_TYPE_ALIASES:
        canonical_type = ATTACK_TYPE_ALIASES[attack_type_lower]
        return VULN_REGISTRY.get(canonical_type)
    
    return None


def get_disclosure_days(severity: str) -> int:
    """
    Get standard disclosure timeline based on severity.
    
    Args:
        severity: Severity level (critical, high, medium, low, info)
        
    Returns:
        Number of days for responsible disclosure
    """
    timeline_map = {
        "critical": 7,
        "high": 21,
        "medium": 45,
        "low": 90,
        "info": 0
    }
    return timeline_map.get(severity.lower(), 45)


def get_owasp_category(cwe_id: str) -> Optional[str]:
    """
    Map CWE ID to OWASP Top 10 2021 category.
    
    Args:
        cwe_id: CWE identifier (e.g., "CWE-89")
        
    Returns:
        OWASP category string or None
    """
    cwe_to_owasp = {
        "CWE-89": "A03:2021 - Injection",
        "CWE-79": "A03:2021 - Injection",
        "CWE-78": "A03:2021 - Injection",
        "CWE-943": "A03:2021 - Injection",
        "CWE-611": "A05:2021 - Security Misconfiguration",
        "CWE-639": "A01:2021 - Broken Access Control",
        "CWE-98": "A01:2021 - Broken Access Control",
        "CWE-434": "A04:2021 - Insecure Design",
        "CWE-287": "A07:2021 - Identification and Authentication Failures",
        "CWE-918": "A10:2021 - Server-Side Request Forgery",
        "CWE-311": "A02:2021 - Cryptographic Failures",
        "CWE-352": "A01:2021 - Broken Access Control",
        "CWE-601": "A01:2021 - Broken Access Control",
        "CWE-347": "A07:2021 - Identification and Authentication Failures",
        "CWE-1336": "A03:2021 - Injection",
    }
    return cwe_to_owasp.get(cwe_id)


def list_all_attack_types() -> List[str]:
    """Get list of all registered attack types."""
    return list(VULN_REGISTRY.keys())


def get_compliance_by_standard(standard: str) -> Dict[str, List[str]]:
    """
    Get vulnerabilities mapped to a specific compliance standard.
    
    Args:
        standard: Compliance standard prefix (e.g., "PCI-DSS", "HIPAA", "SOC 2")
        
    Returns:
        Dict mapping attack_type to relevant compliance requirements
    """
    result = {}
    for attack_type, meta in VULN_REGISTRY.items():
        matching = [c for c in meta.compliance if standard.upper() in c.upper()]
        if matching:
            result[attack_type] = matching
    return result
