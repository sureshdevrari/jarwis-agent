"""
Jarwis Network Security - Exploitation Scanners

Tools:
- CrackMapExec: AD/SMB/WinRM exploitation
- Impacket: Windows protocol attacks
- Metasploit: Full exploitation framework (RPC)
"""

import asyncio
import json
import re
import logging
from typing import Dict, List, Optional

from .base import (
    BaseScanner, ScanResult, Finding, ScanPhase,
    ScannerRegistry, Severity
)

logger = logging.getLogger(__name__)


@ScannerRegistry.register
class CrackMapExecScanner(BaseScanner):
    """
    CrackMapExec (CME/NetExec) - Swiss Army Knife for AD Networks
    
    Multi-protocol network exploitation tool:
    - SMB: Share enumeration, credential testing, command execution
    - WinRM: Remote command execution
    - LDAP: AD enumeration
    - MSSQL: Database attacks
    - SSH: Linux authentication
    
    Essential for authenticated network penetration testing.
    """
    
    TOOL_NAME = "crackmapexec"
    PHASE = ScanPhase.EXPLOITATION
    REQUIRES_ROOT = False
    
    # Protocols supported by CME
    PROTOCOLS = ['smb', 'winrm', 'ldap', 'mssql', 'ssh', 'rdp']
    
    async def run(self, target: str, protocol: str = 'smb',
                  username: str = None, password: str = None,
                  domain: str = None, hash_value: str = None,
                  modules: List[str] = None,
                  enum_shares: bool = True,
                  enum_users: bool = False,
                  **kwargs) -> ScanResult:
        """
        Run CrackMapExec against target.
        
        Args:
            target: IP/hostname/CIDR
            protocol: Protocol to use (smb, winrm, ldap, etc.)
            username: Username for authentication
            password: Password for authentication
            domain: Windows domain
            hash_value: NTLM hash for pass-the-hash
            modules: CME modules to run
            enum_shares: Enumerate shares (SMB)
            enum_users: Enumerate users (LDAP)
        """
        start_time = asyncio.get_event_loop().time()
        
        # Use netexec if available (CME successor)
        cme_cmd = 'netexec' if self._check_tool('netexec') else 'crackmapexec'
        
        cmd = [cme_cmd, protocol, target]
        
        # Authentication
        if username:
            cmd.extend(['-u', username])
        if password:
            cmd.extend(['-p', password])
        if domain:
            cmd.extend(['-d', domain])
        if hash_value:
            cmd.extend(['-H', hash_value])
        
        # Protocol-specific options
        if protocol == 'smb':
            if enum_shares:
                cmd.append('--shares')
        elif protocol == 'ldap':
            if enum_users:
                cmd.append('--users')
        
        # Modules
        if modules:
            for module in modules:
                cmd.extend(['-M', module])
        
        # JSON output
        cmd.extend(['--log', '/dev/stdout'])
        
        stdout, stderr, returncode = await self._run_command(cmd, timeout=300)
        
        result = ScanResult(
            tool=self.TOOL_NAME,
            target=target,
            phase=self.PHASE.value,
            raw_output=stdout,
            error=stderr if returncode != 0 and not stdout else "",
            scan_time=asyncio.get_event_loop().time() - start_time
        )
        
        if stdout:
            result.findings = self.parse_output(stdout, target)
        
        return result
    
    def _check_tool(self, tool: str) -> bool:
        """Check if a tool is available"""
        import shutil
        return shutil.which(tool) is not None
    
    def parse_output(self, raw_output: str, target: str) -> List[Finding]:
        """Parse CrackMapExec output"""
        findings = []
        
        for line in raw_output.strip().split('\n'):
            # Skip empty lines
            if not line.strip():
                continue
            
            # Parse CME colored output patterns
            # [+] indicates success
            if '[+]' in line or 'Pwn3d!' in line:
                # Successful authentication
                if 'Pwn3d!' in line:
                    findings.append(Finding(
                        id=self._generate_id(),
                        tool=self.TOOL_NAME,
                        category="credential",
                        severity=Severity.CRITICAL.value,
                        title="Admin Access Achieved",
                        description="Credentials provide administrative access",
                        target=target,
                        evidence=line,
                        confidence=0.99,
                    ))
                elif any(x in line for x in ['STATUS_SUCCESS', 'Successful']):
                    findings.append(Finding(
                        id=self._generate_id(),
                        tool=self.TOOL_NAME,
                        category="credential",
                        severity=Severity.HIGH.value,
                        title="Valid Credentials",
                        description="Credentials validated successfully",
                        target=target,
                        evidence=line,
                        confidence=0.95,
                    ))
            
            # Share enumeration
            if 'READ' in line or 'WRITE' in line:
                share_match = re.search(r'(\S+)\s+(READ|WRITE)', line)
                if share_match:
                    share_name = share_match.group(1)
                    access = share_match.group(2)
                    
                    severity = Severity.MEDIUM.value if access == 'READ' else Severity.HIGH.value
                    
                    findings.append(Finding(
                        id=self._generate_id(),
                        tool=self.TOOL_NAME,
                        category="misconfiguration",
                        severity=severity,
                        title=f"Accessible Share: {share_name}",
                        description=f"Share has {access} access",
                        target=target,
                        service='smb',
                        port=445,
                        evidence=line,
                        confidence=0.95,
                    ))
            
            # SMB signing
            if 'signing:False' in line.lower() or 'message_signing: disabled' in line.lower():
                findings.append(Finding(
                    id=self._generate_id(),
                    tool=self.TOOL_NAME,
                    category="misconfiguration",
                    severity=Severity.MEDIUM.value,
                    title="SMB Signing Disabled",
                    description="SMB signing not required, vulnerable to relay attacks",
                    target=target,
                    service='smb',
                    port=445,
                    evidence=line,
                    confidence=0.99,
                    remediation="Enable SMB signing via Group Policy",
                ))
            
            # Null session
            if 'null session' in line.lower() or "'' ''" in line:
                findings.append(Finding(
                    id=self._generate_id(),
                    tool=self.TOOL_NAME,
                    category="misconfiguration",
                    severity=Severity.HIGH.value,
                    title="Null Session Allowed",
                    description="Anonymous/null session access permitted",
                    target=target,
                    service='smb',
                    port=445,
                    evidence=line,
                    confidence=0.95,
                    remediation="Disable null sessions via registry/GPO",
                ))
        
        return findings


@ScannerRegistry.register
class ImpacketScanner(BaseScanner):
    """
    Impacket - Windows Protocol Implementation
    
    Collection of Python classes for working with network protocols:
    - SMB/CIFS
    - MSRPC
    - LDAP
    - Kerberos
    - MSSQL
    
    Tools included:
    - secretsdump: Extract credentials
    - GetNPUsers: AS-REP roasting
    - GetUserSPNs: Kerberoasting
    - smbclient: SMB enumeration
    - wmiexec/psexec: Remote execution
    """
    
    TOOL_NAME = "impacket"
    PHASE = ScanPhase.EXPLOITATION
    REQUIRES_ROOT = False
    
    async def run(self, target: str, module: str = 'smbclient',
                  username: str = None, password: str = None,
                  domain: str = None, hash_value: str = None,
                  **kwargs) -> ScanResult:
        """
        Run Impacket module against target.
        
        Args:
            target: IP/hostname
            module: Impacket script to run
            username: Username
            password: Password
            domain: Windows domain
            hash_value: NTLM hash
        """
        start_time = asyncio.get_event_loop().time()
        
        result = ScanResult(
            tool=self.TOOL_NAME,
            target=target,
            phase=self.PHASE.value,
        )
        
        # Route to specific Impacket tool
        if module == 'secretsdump':
            result = await self._run_secretsdump(target, username, password, domain, hash_value)
        elif module == 'getuserspns':
            result = await self._run_kerberoast(target, username, password, domain)
        elif module == 'getnpusers':
            result = await self._run_asreproast(target, username, password, domain)
        elif module == 'smbclient':
            result = await self._run_smbclient(target, username, password, domain)
        else:
            result.error = f"Unknown module: {module}"
        
        result.scan_time = asyncio.get_event_loop().time() - start_time
        return result
    
    async def _run_secretsdump(self, target: str, username: str,
                                password: str, domain: str,
                                hash_value: str = None) -> ScanResult:
        """Run secretsdump.py for credential extraction"""
        cmd = ['impacket-secretsdump']
        
        if hash_value:
            cmd.append(f'{domain}/{username}@{target}')
            cmd.extend(['-hashes', f':{hash_value}'])
        else:
            cmd.append(f'{domain}/{username}:{password}@{target}')
        
        stdout, stderr, returncode = await self._run_command(cmd, timeout=300)
        
        result = ScanResult(
            tool=self.TOOL_NAME,
            target=target,
            phase=self.PHASE.value,
            raw_output=stdout,
            error=stderr if returncode != 0 and not stdout else "",
        )
        
        # Parse for hashes
        findings = []
        if stdout:
            # SAM hashes
            sam_pattern = re.compile(r'(\S+):(\d+):([a-fA-F0-9]{32}):([a-fA-F0-9]{32})')
            for match in sam_pattern.finditer(stdout):
                findings.append(Finding(
                    id=self._generate_id(),
                    tool=self.TOOL_NAME,
                    category="credential",
                    severity=Severity.CRITICAL.value,
                    title=f"SAM Hash Extracted: {match.group(1)}",
                    description="Local account hash extracted via secretsdump",
                    target=target,
                    evidence=f"{match.group(1)}:{match.group(2)}:***:***",
                    confidence=0.99,
                    metadata={
                        'username': match.group(1),
                        'rid': match.group(2),
                    }
                ))
            
            # Cached credentials
            if 'Cached Credentials' in stdout:
                findings.append(Finding(
                    id=self._generate_id(),
                    tool=self.TOOL_NAME,
                    category="credential",
                    severity=Severity.HIGH.value,
                    title="Cached Domain Credentials Found",
                    description="Domain cached credentials extracted",
                    target=target,
                    confidence=0.95,
                ))
            
            # LSA Secrets
            if 'LSA Secrets' in stdout:
                findings.append(Finding(
                    id=self._generate_id(),
                    tool=self.TOOL_NAME,
                    category="credential",
                    severity=Severity.HIGH.value,
                    title="LSA Secrets Extracted",
                    description="LSA secrets including service account credentials",
                    target=target,
                    confidence=0.95,
                ))
        
        result.findings = findings
        return result
    
    async def _run_kerberoast(self, target: str, username: str,
                               password: str, domain: str) -> ScanResult:
        """Run GetUserSPNs.py for Kerberoasting"""
        cmd = [
            'impacket-GetUserSPNs',
            f'{domain}/{username}:{password}',
            '-dc-ip', target,
            '-request'
        ]
        
        stdout, stderr, returncode = await self._run_command(cmd, timeout=120)
        
        result = ScanResult(
            tool=self.TOOL_NAME,
            target=target,
            phase=self.PHASE.value,
            raw_output=stdout,
            error=stderr if returncode != 0 and not stdout else "",
        )
        
        findings = []
        if stdout:
            # Look for Kerberos tickets
            ticket_pattern = re.compile(r'\$krb5tgs\$\d+\$\*([^*]+)\*')
            for match in ticket_pattern.finditer(stdout):
                findings.append(Finding(
                    id=self._generate_id(),
                    tool=self.TOOL_NAME,
                    category="credential",
                    severity=Severity.HIGH.value,
                    title=f"Kerberoastable Account: {match.group(1)}",
                    description="Service account with SPN, ticket can be cracked offline",
                    target=target,
                    evidence=f"Service: {match.group(1)}",
                    confidence=0.99,
                    remediation="Use long, complex passwords for service accounts",
                ))
        
        result.findings = findings
        return result
    
    async def _run_asreproast(self, target: str, username: str = None,
                               password: str = None, domain: str = None) -> ScanResult:
        """Run GetNPUsers.py for AS-REP roasting"""
        cmd = ['impacket-GetNPUsers', f'{domain}/', '-dc-ip', target]
        
        if username:
            cmd.extend(['-usersfile', '-'])  # Will need user list
        else:
            cmd.append('-request')
        
        stdout, stderr, returncode = await self._run_command(cmd, timeout=120)
        
        result = ScanResult(
            tool=self.TOOL_NAME,
            target=target,
            phase=self.PHASE.value,
            raw_output=stdout,
            error=stderr if returncode != 0 and not stdout else "",
        )
        
        findings = []
        if stdout:
            # Look for AS-REP hashes
            asrep_pattern = re.compile(r'\$krb5asrep\$\d+\$([^:]+)@')
            for match in asrep_pattern.finditer(stdout):
                findings.append(Finding(
                    id=self._generate_id(),
                    tool=self.TOOL_NAME,
                    category="credential",
                    severity=Severity.HIGH.value,
                    title=f"AS-REP Roastable: {match.group(1)}",
                    description="Account has 'Do not require Kerberos preauthentication'",
                    target=target,
                    evidence=f"User: {match.group(1)}",
                    confidence=0.99,
                    remediation="Enable Kerberos pre-authentication for this account",
                ))
        
        result.findings = findings
        return result
    
    async def _run_smbclient(self, target: str, username: str = None,
                              password: str = None, domain: str = None) -> ScanResult:
        """Run smbclient.py for SMB enumeration"""
        cmd = ['impacket-smbclient']
        
        if username and password:
            cmd.append(f'{domain}/{username}:{password}@{target}')
        else:
            cmd.append(f'guest:@{target}')
        
        # Just list shares
        cmd.extend(['-c', 'shares'])
        
        stdout, stderr, returncode = await self._run_command(cmd, timeout=60)
        
        result = ScanResult(
            tool=self.TOOL_NAME,
            target=target,
            phase=self.PHASE.value,
            raw_output=stdout,
            error=stderr if returncode != 0 and not stdout else "",
        )
        
        findings = []
        if stdout:
            for line in stdout.strip().split('\n'):
                if 'DISK' in line or 'IPC' in line or 'PRINTER' in line:
                    share_match = re.search(r'^(\S+)', line)
                    if share_match:
                        findings.append(Finding(
                            id=self._generate_id(),
                            tool=self.TOOL_NAME,
                            category="enumeration",
                            severity=Severity.INFO.value,
                            title=f"SMB Share: {share_match.group(1)}",
                            description="Share discovered via SMB enumeration",
                            target=target,
                            port=445,
                            service='smb',
                            evidence=line,
                            confidence=0.95,
                        ))
        
        result.findings = findings
        return result
    
    def parse_output(self, raw_output: str, target: str) -> List[Finding]:
        """Generic output parser"""
        return []


@ScannerRegistry.register
class MetasploitScanner(BaseScanner):
    """
    Metasploit Framework - Exploitation Platform
    
    Industry-standard exploitation framework:
    - Vulnerability verification
    - Exploit execution
    - Post-exploitation
    - Payload generation
    
    Uses Metasploit RPC API for automation.
    
    Note: Jarwis uses Metasploit for verification, not blind exploitation.
    """
    
    TOOL_NAME = "metasploit"
    PHASE = ScanPhase.EXPLOITATION
    REQUIRES_ROOT = True
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        self.msf_host = config.get('msf_host', '127.0.0.1')
        self.msf_port = config.get('msf_port', 55553)
        self.msf_user = config.get('msf_user', 'msf')
        self.msf_password = config.get('msf_password', '')
    
    async def run(self, target: str, module: str = None,
                  module_type: str = 'auxiliary',
                  options: Dict = None, **kwargs) -> ScanResult:
        """
        Run Metasploit module via RPC.
        
        Args:
            target: Target IP/hostname
            module: Module path (e.g., 'scanner/smb/smb_ms17_010')
            module_type: auxiliary, exploit, post
            options: Module options
        """
        start_time = asyncio.get_event_loop().time()
        
        result = ScanResult(
            tool=self.TOOL_NAME,
            target=target,
            phase=self.PHASE.value,
        )
        
        if not module:
            result.error = "No module specified"
            return result
        
        try:
            # Try msgpack RPC first
            from pymetasploit3.msfrpc import MsfRpcClient
            
            client = MsfRpcClient(
                password=self.msf_password,
                server=self.msf_host,
                port=self.msf_port,
                username=self.msf_user,
                ssl=True
            )
            
            # Get module
            if module_type == 'auxiliary':
                mod = client.modules.use('auxiliary', module)
            elif module_type == 'exploit':
                mod = client.modules.use('exploit', module)
            else:
                mod = client.modules.use(module_type, module)
            
            # Set target
            mod['RHOSTS'] = target
            
            # Set additional options
            if options:
                for key, value in options.items():
                    mod[key] = value
            
            # Execute
            job_id = mod.execute()
            
            # Wait for completion
            output = await self._wait_for_job(client, job_id)
            
            result.raw_output = output
            result.findings = self._parse_msf_output(output, target, module)
            
        except ImportError:
            # Fall back to msfconsole resource file
            result = await self._run_msfconsole(target, module, module_type, options)
        except Exception as e:
            result.error = str(e)
            logger.error(f"Metasploit scan failed: {e}")
        
        result.scan_time = asyncio.get_event_loop().time() - start_time
        return result
    
    async def _wait_for_job(self, client, job_id: str, timeout: int = 300) -> str:
        """Wait for MSF job to complete"""
        import time
        start = time.time()
        output = []
        
        while time.time() - start < timeout:
            if job_id not in client.jobs.list:
                break
            await asyncio.sleep(2)
        
        # Collect console output
        return '\n'.join(output)
    
    async def _run_msfconsole(self, target: str, module: str,
                               module_type: str, options: Dict) -> ScanResult:
        """Run module via msfconsole"""
        # Create resource file
        import tempfile
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
            f.write(f"use {module_type}/{module}\n")
            f.write(f"set RHOSTS {target}\n")
            if options:
                for key, value in options.items():
                    f.write(f"set {key} {value}\n")
            f.write("run\n")
            f.write("exit\n")
            rc_file = f.name
        
        cmd = ['msfconsole', '-q', '-r', rc_file]
        
        stdout, stderr, returncode = await self._run_command(cmd, timeout=300)
        
        # Clean up
        import os
        os.unlink(rc_file)
        
        result = ScanResult(
            tool=self.TOOL_NAME,
            target=target,
            phase=self.PHASE.value,
            raw_output=stdout,
            error=stderr if returncode != 0 and not stdout else "",
        )
        
        result.findings = self._parse_msf_output(stdout, target, module)
        
        return result
    
    def _parse_msf_output(self, output: str, target: str, module: str) -> List[Finding]:
        """Parse Metasploit output"""
        findings = []
        
        if not output:
            return findings
        
        # Look for vulnerable indicators
        vulnerable_patterns = [
            r'\[!\].*vulnerable',
            r'\[\+\].*vulnerable',
            r'Host is likely VULNERABLE',
            r'Target is vulnerable',
        ]
        
        for pattern in vulnerable_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                # Extract specific vulnerability info
                module_name = module.split('/')[-1] if module else 'unknown'
                
                findings.append(Finding(
                    id=self._generate_id(),
                    tool=self.TOOL_NAME,
                    category="vulnerability",
                    severity=Severity.HIGH.value,
                    title=f"Metasploit Verified: {module_name}",
                    description=f"Vulnerability confirmed via Metasploit module {module}",
                    target=target,
                    evidence=output[:500],
                    confidence=0.95,
                ))
                break
        
        # MS17-010 specific
        if 'ms17_010' in module.lower() or 'eternalblue' in module.lower():
            if 'VULNERABLE' in output.upper():
                findings.append(Finding(
                    id=self._generate_id(),
                    tool=self.TOOL_NAME,
                    category="vulnerability",
                    severity=Severity.CRITICAL.value,
                    title="MS17-010 EternalBlue",
                    description="System vulnerable to EternalBlue (CVE-2017-0144)",
                    target=target,
                    port=445,
                    service='smb',
                    cve_id='CVE-2017-0144',
                    cvss_score=9.8,
                    confidence=0.99,
                    remediation="Apply Microsoft security update MS17-010",
                ))
        
        return findings
    
    def parse_output(self, raw_output: str, target: str) -> List[Finding]:
        """Generic parser"""
        return self._parse_msf_output(raw_output, target, "")
